<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Infinite Stack Climb</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1a1a2e;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 100vh;
      max-height: 700px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 10px;
    }
    #ui {
      position: absolute;
      top: 15px;
      left: 15px;
      right: 15px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      color: #fff;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      pointer-events: none;
      z-index: 10;
    }
    .stat-box {
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(10px);
      padding: 10px 15px;
      border-radius: 12px;
      text-align: center;
    }
    .stat-label { font-size: 10px; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; }
    .stat-value { font-size: 24px; margin-top: 2px; }
    #comboBox { 
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    #comboBox.show { opacity: 1; }
    #comboBox .stat-value { color: #ffd700; }
    #altitude {
      position: absolute;
      right: 15px;
      top: 70px;
      color: #fff;
      font-size: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      opacity: 0.8;
    }
    #powerups {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }
    .powerup-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.3);
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
      font-size: 22px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, opacity 0.2s, border-color 0.2s;
      position: relative;
    }
    .powerup-btn:hover { transform: scale(1.1); border-color: #fff; }
    .powerup-btn.disabled { opacity: 0.3; pointer-events: none; }
    .powerup-btn.active { border-color: #ffd700; box-shadow: 0 0 15px rgba(255,215,0,0.5); }
    .powerup-count {
      position: absolute;
      bottom: -5px;
      right: -5px;
      background: #ff6b6b;
      color: #fff;
      font-size: 10px;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }
    #menu, #gameover {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.85);
      color: #fff;
      border-radius: 10px;
      z-index: 100;
    }
    #menu h1, #gameover h1 {
      font-size: 36px;
      margin-bottom: 10px;
    }
    #menu h1 span { 
      background: linear-gradient(135deg, #ff6b6b, #ffd93d, #4ecdc4, #667eea);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #menu p, #gameover p {
      font-size: 14px;
      margin-bottom: 20px;
      color: #888;
      text-align: center;
      padding: 0 20px;
    }
    .btn {
      padding: 15px 50px;
      font-size: 18px;
      font-weight: bold;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      margin: 8px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover { transform: scale(1.05); }
    .btn-play {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      box-shadow: 0 5px 20px rgba(102,126,234,0.5);
    }
    .btn-retry {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: #fff;
      box-shadow: 0 5px 20px rgba(255,100,100,0.5);
    }
    #finalScore {
      font-size: 56px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    #finalHeight { font-size: 18px; color: #4ecdc4; margin-top: 5px; }
    #bestScore { font-size: 16px; color: #ffd700; margin-top: 8px; }
    #newBest { color: #ff6b6b; font-size: 14px; animation: pulse 0.5s infinite alternate; margin-top: 5px; }
    @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }
    .hidden { display: none !important; }
    #perfectText {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.4);
      opacity: 0;
      pointer-events: none;
      z-index: 20;
    }
    #perfectText.show {
      animation: perfectPop 0.5s ease-out forwards;
    }
    @keyframes perfectPop {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-30px); }
    }
    .stats-row {
      display: flex;
      gap: 30px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .stats-row .stat { text-align: center; }
    .stats-row .stat-label { font-size: 11px; color: #888; }
    .stats-row .stat-value { font-size: 20px; margin-top: 3px; }
    #menuBest { color: #ffd700; font-size: 18px; }
    .how-to-play {
      margin-top: 25px;
      padding: 15px 25px;
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      font-size: 12px;
      color: #aaa;
      text-align: left;
      max-width: 280px;
    }
    .how-to-play h3 { color: #fff; margin-bottom: 8px; font-size: 13px; }
    .how-to-play ul { margin-left: 15px; line-height: 1.8; }
    .phase-indicator {
      position: absolute;
      top: 75px;
      left: 15px;
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
  </style>
<script src="../i18n.js"></script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>
    
    <div id="ui">
      <div class="stat-box">
        <div class="stat-label">Score</div>
        <div class="stat-value" id="score">0</div>
      </div>
      <div class="stat-box" id="comboBox">
        <div class="stat-label">Combo</div>
        <div class="stat-value" id="combo">x1</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Best</div>
        <div class="stat-value" id="best">0</div>
      </div>
    </div>
    
    <div id="altitude">ğŸ”ï¸ 0m</div>
    <div class="phase-indicator" id="phase">â˜€ï¸ ë‚®</div>
    
    <div id="powerups" class="hidden">
      <button class="powerup-btn" id="pwMagnet" title="ìì„ - ìë™ ì •ë ¬">ğŸ§²<span class="powerup-count">3</span></button>
      <button class="powerup-btn" id="pwSlow" title="ìŠ¬ë¡œìš° - ì†ë„ ê°ì†Œ">â±ï¸<span class="powerup-count">3</span></button>
      <button class="powerup-btn" id="pwDouble" title="2ë°° ì ìˆ˜">âœ¨<span class="powerup-count">3</span></button>
    </div>
    
    <div id="perfectText">PERFECT!</div>
    
    <div id="menu">
      <h1>ğŸ—ï¸ <span>Infinite Stack</span></h1>
      <p>í•˜ëŠ˜ ëê¹Œì§€ ìŒ“ì•„ ì˜¬ë¼ê°€ì„¸ìš”!<br>ì™„ë²½í•œ íƒ€ì´ë°ì— íƒ­í•˜ë©´ ì½¤ë³´ ë³´ë„ˆìŠ¤!</p>
      <button class="btn btn-play" onclick="startGame()">â–¶ PLAY</button>
      <p style="margin-top:15px">ğŸ† ìµœê³  ê¸°ë¡: <span id="menuBest">0</span></p>
      <div class="how-to-play">
        <h3>ğŸ® ì¡°ì‘ë²•</h3>
        <ul>
          <li><strong>íƒ­/í´ë¦­</strong> - ë¸”ë¡ ë°°ì¹˜</li>
          <li><strong>Perfect</strong> - ì½¤ë³´ ëˆ„ì , ë¸”ë¡ í™•ì¥</li>
          <li>ë†’ì´ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì†ë„ ì¦ê°€!</li>
          <li>ë°°ê²½ì´ ë‚®â†’ì €ë…â†’ë°¤â†’ìš°ì£¼ë¡œ ë³€í•´ìš”</li>
        </ul>
      </div>
    </div>
    
    <div id="gameover" class="hidden">
      <h1>GAME OVER</h1>
      <div id="finalScore">0</div>
      <div id="finalHeight">ìµœê³  ë†’ì´: 0m</div>
      <div id="bestScore">Best: 0</div>
      <div id="newBest" class="hidden">ğŸ‰ NEW RECORD!</div>
      <div class="stats-row">
        <div class="stat">
          <div class="stat-label">ìµœëŒ€ ì½¤ë³´</div>
          <div class="stat-value" id="maxCombo">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Perfect</div>
          <div class="stat-value" id="perfectCount">0</div>
        </div>
      </div>
      <button class="btn btn-retry" onclick="startGame()">ğŸ”„ RETRY</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ê²Œì„ ë°¸ëŸ°ìŠ¤ ìƒìˆ˜
    const BALANCE = {
      block: {
        initialWidth: 180,
        minWidth: 12,
        height: 22,
        perfectThreshold: 6,
      },
      speed: {
        initial: 3,
        increment: 0.15,
        max: 12,
      },
      scoring: {
        base: 10,
        perfectBonus: 50,
        comboMultiplier: 0.1,
      },
      perfectBonus: {
        growWidth: 6,
        comboRequired: 3,
      },
      phases: [
        { name: 'â˜€ï¸ ë‚®', minHeight: 0, colors: ['#87CEEB', '#E0F6FF'], buildingColor: '#2d3436' },
        { name: 'ğŸŒ… ì €ë…', minHeight: 30, colors: ['#ff7e5f', '#feb47b'], buildingColor: '#1a1a2e' },
        { name: 'ğŸŒ™ ë°¤', minHeight: 60, colors: ['#0f0c29', '#302b63', '#24243e'], buildingColor: '#0a0a15' },
        { name: 'ğŸš€ ìš°ì£¼', minHeight: 100, colors: ['#000000', '#0a0a20', '#1a0a30'], buildingColor: '#05050a' },
      ]
    };

    // ê²Œì„ ìƒíƒœ
    let gameState = 'menu';
    let score = 0;
    let combo = 0;
    let maxCombo = 0;
    let perfectCount = 0;
    let bestScore = parseInt(localStorage.getItem('infiniteStackBest') || '0');
    let tower = [];
    let currentBlock = null;
    let fallingPieces = [];
    let particles = [];
    let cameraY = 0;
    let targetCameraY = 0;
    let speed = BALANCE.speed.initial;
    let currentPhase = 0;
    let stars = [];
    
    // íŒŒì›Œì—… ìƒíƒœ
    let powerups = { magnet: 3, slow: 3, double: 3 };
    let activePowerup = null;
    let powerupTimer = 0;

    // ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ì¸µë³„ ê·¸ë¼ë°ì´ì…˜)
    const blockColors = [
      '#ff6b6b', '#ff8787', '#ffa07a',
      '#ffd93d', '#ffe066', '#fff3bf',
      '#6bcb77', '#7ed687', '#95e1a3',
      '#4d96ff', '#74b3ff', '#a0c8ff',
      '#9b59b6', '#b377d9', '#c99be0',
      '#ff9f43', '#ffb76b', '#ffd093',
    ];

    function getBlockColor(index) {
      return blockColors[index % blockColors.length];
    }

    function getCurrentPhase() {
      const height = tower.length;
      for (let i = BALANCE.phases.length - 1; i >= 0; i--) {
        if (height >= BALANCE.phases[i].minHeight) return i;
      }
      return 0;
    }

    function generateStars() {
      stars = [];
      for (let i = 0; i < 100; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * 2 + 0.5,
          twinkle: Math.random() * Math.PI * 2
        });
      }
    }

    function init() {
      document.getElementById('menuBest').textContent = bestScore;
      document.getElementById('best').textContent = bestScore;
      tower = [];
      fallingPieces = [];
      particles = [];
      score = 0;
      combo = 0;
      maxCombo = 0;
      perfectCount = 0;
      cameraY = 0;
      targetCameraY = 0;
      speed = BALANCE.speed.initial;
      currentPhase = 0;
      powerups = { magnet: 3, slow: 3, double: 3 };
      activePowerup = null;
      powerupTimer = 0;
      
      generateStars();
      updatePowerupUI();
      
      // ë² ì´ìŠ¤ ë¸”ë¡
      const baseWidth = BALANCE.block.initialWidth;
      tower.push({
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: baseWidth,
        color: getBlockColor(0)
      });
      
      spawnBlock();
    }

    function spawnBlock() {
      const lastBlock = tower[tower.length - 1];
      currentBlock = {
        x: -BALANCE.block.initialWidth / 2,
        y: lastBlock.y - BALANCE.block.height - 40,
        width: lastBlock.width,
        direction: 1,
        color: getBlockColor(tower.length)
      };
    }

    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8 - 3,
          color,
          size: Math.random() * 4 + 2,
          life: 1
        });
      }
    }

    function dropBlock() {
      if (!currentBlock || gameState !== 'playing') return;
      
      const lastBlock = tower[tower.length - 1];
      let diff = currentBlock.x - lastBlock.x;
      
      // ìì„ íŒŒì›Œì—…: ìë™ ì •ë ¬
      if (activePowerup === 'magnet') {
        if (Math.abs(diff) < currentBlock.width * 0.7) {
          diff = 0; // ì™„ë²½ ì •ë ¬
        }
      }
      
      const overlap = currentBlock.width / 2 + lastBlock.width / 2 - Math.abs(diff);
      
      if (overlap <= 0) {
        // ì™„ì „íˆ ë¹—ë‚˜ê°
        fallingPieces.push({
          x: currentBlock.x,
          y: currentBlock.y,
          width: currentBlock.width,
          color: currentBlock.color,
          vx: currentBlock.direction * 5,
          vy: 0,
          rotation: 0,
          rotationSpeed: currentBlock.direction * 0.1
        });
        gameOver();
        return;
      }
      
      let newWidth, newX;
      const isPerfect = Math.abs(diff) <= BALANCE.block.perfectThreshold;
      
      if (isPerfect) {
        // Perfect ë°°ì¹˜
        combo++;
        perfectCount++;
        if (combo > maxCombo) maxCombo = combo;
        
        newX = lastBlock.x;
        
        // ì½¤ë³´ 3íšŒ ì´ìƒì´ë©´ ë¸”ë¡ í™•ì¥
        if (combo >= BALANCE.perfectBonus.comboRequired) {
          newWidth = Math.min(currentBlock.width + BALANCE.perfectBonus.growWidth, BALANCE.block.initialWidth);
        } else {
          newWidth = currentBlock.width;
        }
        
        // ì ìˆ˜ ê³„ì‚° (2ë°° ì ìˆ˜ íŒŒì›Œì—… ì ìš©)
        let points = BALANCE.scoring.base + BALANCE.scoring.perfectBonus;
        points += Math.floor(points * combo * BALANCE.scoring.comboMultiplier);
        if (activePowerup === 'double') points *= 2;
        score += points;
        
        showPerfect();
        createParticles(newX, lastBlock.y - BALANCE.block.height, '#ffd700', 15);
        
      } else {
        combo = 0;
        newWidth = overlap;
        newX = diff > 0 
          ? lastBlock.x + (lastBlock.width / 2 - overlap / 2) + overlap / 2
          : lastBlock.x - (lastBlock.width / 2 - overlap / 2) - overlap / 2;
        
        // ë–¨ì–´ì§€ëŠ” ì¡°ê° ìƒì„±
        const sliceWidth = currentBlock.width - overlap;
        const sliceX = diff > 0
          ? currentBlock.x + overlap / 2 + sliceWidth / 2
          : currentBlock.x - overlap / 2 - sliceWidth / 2;
        
        fallingPieces.push({
          x: sliceX,
          y: currentBlock.y,
          width: sliceWidth,
          color: currentBlock.color,
          vx: diff > 0 ? 4 : -4,
          vy: 0,
          rotation: 0,
          rotationSpeed: diff > 0 ? 0.08 : -0.08
        });
        
        let points = BALANCE.scoring.base;
        if (activePowerup === 'double') points *= 2;
        score += points;
      }
      
      // ê²Œì„ ì˜¤ë²„ ì²´í¬
      if (newWidth < BALANCE.block.minWidth) {
        gameOver();
        return;
      }
      
      // íƒ€ì›Œì— ì¶”ê°€
      tower.push({
        x: newX,
        y: lastBlock.y - BALANCE.block.height,
        width: newWidth,
        color: currentBlock.color
      });
      
      // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
      if (tower.length > 5) {
        targetCameraY = (tower.length - 5) * BALANCE.block.height;
      }
      
      // ì†ë„ ì¦ê°€ (ìŠ¬ë¡œìš° íŒŒì›Œì—… ì‹œ ì ˆë°˜)
      const speedInc = activePowerup === 'slow' ? BALANCE.speed.increment / 2 : BALANCE.speed.increment;
      speed = Math.min(speed + speedInc, BALANCE.speed.max);
      
      // í˜ì´ì¦ˆ ì—…ë°ì´íŠ¸
      const newPhase = getCurrentPhase();
      if (newPhase !== currentPhase) {
        currentPhase = newPhase;
        createParticles(canvas.width / 2, canvas.height / 2, '#fff', 30);
      }
      
      updateUI();
      spawnBlock();
    }

    function showPerfect() {
      const text = document.getElementById('perfectText');
      if (combo >= 5) {
        text.textContent = `ğŸ”¥ PERFECT x${combo}!`;
      } else if (combo >= 3) {
        text.textContent = `âœ¨ PERFECT x${combo}!`;
      } else {
        text.textContent = 'PERFECT!';
      }
      text.classList.remove('show');
      void text.offsetWidth; // reflow
      text.classList.add('show');
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('altitude').textContent = `ğŸ”ï¸ ${(tower.length - 1) * 3}m`;
      document.getElementById('phase').textContent = BALANCE.phases[currentPhase].name;
      
      const comboBox = document.getElementById('comboBox');
      if (combo >= 2) {
        document.getElementById('combo').textContent = `x${combo}`;
        comboBox.classList.add('show');
      } else {
        comboBox.classList.remove('show');
      }
    }

    function updatePowerupUI() {
      document.getElementById('pwMagnet').querySelector('.powerup-count').textContent = powerups.magnet;
      document.getElementById('pwSlow').querySelector('.powerup-count').textContent = powerups.slow;
      document.getElementById('pwDouble').querySelector('.powerup-count').textContent = powerups.double;
      
      document.getElementById('pwMagnet').classList.toggle('disabled', powerups.magnet <= 0);
      document.getElementById('pwSlow').classList.toggle('disabled', powerups.slow <= 0);
      document.getElementById('pwDouble').classList.toggle('disabled', powerups.double <= 0);
      
      // í™œì„±í™” í‘œì‹œ
      document.getElementById('pwMagnet').classList.toggle('active', activePowerup === 'magnet');
      document.getElementById('pwSlow').classList.toggle('active', activePowerup === 'slow');
      document.getElementById('pwDouble').classList.toggle('active', activePowerup === 'double');
    }

    function activatePowerup(type) {
      if (gameState !== 'playing') return;
      if (powerups[type] <= 0) return;
      if (activePowerup === type) return;
      
      powerups[type]--;
      activePowerup = type;
      powerupTimer = 300; // 5ì´ˆ (60fps ê¸°ì¤€)
      updatePowerupUI();
    }

    function gameOver() {
      gameState = 'gameover';
      
      const isNewBest = score > bestScore;
      if (isNewBest) {
        bestScore = score;
        localStorage.setItem('infiniteStackBest', bestScore);
      }
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('finalHeight').textContent = `ìµœê³  ë†’ì´: ${(tower.length - 1) * 3}m`;
      document.getElementById('bestScore').textContent = `Best: ${bestScore}`;
      document.getElementById('newBest').classList.toggle('hidden', !isNewBest);
      document.getElementById('maxCombo').textContent = maxCombo;
      document.getElementById('perfectCount').textContent = perfectCount;
      document.getElementById('gameover').classList.remove('hidden');
      document.getElementById('powerups').classList.add('hidden');
    }

    function startGame() {
      document.getElementById('menu').classList.add('hidden');
      document.getElementById('gameover').classList.add('hidden');
      document.getElementById('powerups').classList.remove('hidden');
      gameState = 'playing';
      init();
      updateUI();
    }

    function update() {
      if (gameState !== 'playing') return;
      
      // íŒŒì›Œì—… íƒ€ì´ë¨¸
      if (activePowerup && powerupTimer > 0) {
        powerupTimer--;
        if (powerupTimer <= 0) {
          activePowerup = null;
          updatePowerupUI();
        }
      }
      
      // í˜„ì¬ ë¸”ë¡ ì´ë™
      if (currentBlock) {
        const currentSpeed = activePowerup === 'slow' ? speed * 0.5 : speed;
        currentBlock.x += currentSpeed * currentBlock.direction;
        
        // ë²½ì— ë‹¿ìœ¼ë©´ ë°©í–¥ ì „í™˜
        const halfWidth = currentBlock.width / 2;
        if (currentBlock.x + halfWidth > canvas.width) {
          currentBlock.x = canvas.width - halfWidth;
          currentBlock.direction = -1;
        } else if (currentBlock.x - halfWidth < 0) {
          currentBlock.x = halfWidth;
          currentBlock.direction = 1;
        }
      }
      
      // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™
      cameraY += (targetCameraY - cameraY) * 0.08;
      
      // ë–¨ì–´ì§€ëŠ” ì¡°ê° ì—…ë°ì´íŠ¸
      fallingPieces.forEach(p => {
        p.vy += 0.6;
        p.x += p.vx;
        p.y += p.vy;
        p.rotation += p.rotationSpeed;
      });
      fallingPieces = fallingPieces.filter(p => p.y < canvas.height + 200);
      
      // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.2;
        p.life -= 0.02;
        p.size *= 0.98;
      });
      particles = particles.filter(p => p.life > 0);
      
      // ë³„ ë°˜ì§ì„ ì—…ë°ì´íŠ¸
      stars.forEach(s => {
        s.twinkle += 0.05;
      });
    }

    function drawBackground() {
      const phase = BALANCE.phases[currentPhase];
      const colors = phase.colors;
      
      // ê·¸ë¼ë°ì´ì…˜ ë°°ê²½
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      colors.forEach((color, i) => {
        gradient.addColorStop(i / (colors.length - 1), color);
      });
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // ë°¤/ìš°ì£¼ í˜ì´ì¦ˆì—ì„œ ë³„ ê·¸ë¦¬ê¸°
      if (currentPhase >= 2) {
        stars.forEach(star => {
          const alpha = 0.3 + Math.sin(star.twinkle) * 0.3;
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.beginPath();
          ctx.arc(star.x, star.y - cameraY * 0.1, star.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
      
      // ë°°ê²½ ê±´ë¬¼ (ë‚®/ì €ë… í˜ì´ì¦ˆ)
      if (currentPhase < 2) {
        ctx.fillStyle = phase.buildingColor;
        for (let i = 0; i < 8; i++) {
          const bw = 40 + Math.random() * 30;
          const bh = 100 + Math.random() * 150;
          const bx = i * 55 + 10;
          ctx.fillRect(bx, canvas.height - bh + cameraY * 0.3, bw, bh);
          
          // ê±´ë¬¼ ì°½ë¬¸
          ctx.fillStyle = 'rgba(255,200,100,0.3)';
          for (let wy = canvas.height - bh + 20 + cameraY * 0.3; wy < canvas.height; wy += 25) {
            for (let wx = bx + 8; wx < bx + bw - 8; wx += 15) {
              if (Math.random() > 0.3) {
                ctx.fillRect(wx, wy, 8, 12);
              }
            }
          }
          ctx.fillStyle = phase.buildingColor;
        }
      }
    }

    function drawBlock(x, y, width, height, color, rotation = 0) {
      ctx.save();
      ctx.translate(x, y + height / 2);
      ctx.rotate(rotation);
      
      const left = -width / 2;
      const top = -height / 2;
      
      // ê·¸ë¦¼ì
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.fillRect(left + 4, top + 4, width, height);
      
      // ë©”ì¸ ë¸”ë¡
      ctx.fillStyle = color;
      ctx.fillRect(left, top, width, height);
      
      // í•˜ì´ë¼ì´íŠ¸ (ìƒë‹¨)
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fillRect(left, top, width, height * 0.35);
      
      // í…Œë‘ë¦¬
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 1;
      ctx.strokeRect(left, top, width, height);
      
      ctx.restore();
    }

    function draw() {
      drawBackground();
      
      ctx.save();
      ctx.translate(0, cameraY);
      
      // íƒ€ì›Œ ê·¸ë¦¬ê¸°
      tower.forEach((block, i) => {
        drawBlock(block.x, block.y, block.width, BALANCE.block.height, block.color);
      });
      
      // í˜„ì¬ ë¸”ë¡ ê·¸ë¦¬ê¸°
      if (currentBlock && gameState === 'playing') {
        drawBlock(currentBlock.x, currentBlock.y, currentBlock.width, BALANCE.block.height, currentBlock.color);
        
        // ê°€ì´ë“œ ë¼ì¸
        const lastBlock = tower[tower.length - 1];
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.setLineDash([8, 8]);
        ctx.beginPath();
        ctx.moveTo(currentBlock.x, currentBlock.y + BALANCE.block.height);
        ctx.lineTo(currentBlock.x, lastBlock.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // íƒ€ê²Ÿ ì˜ì—­ í‘œì‹œ
        ctx.strokeStyle = 'rgba(255,215,0,0.3)';
        ctx.lineWidth = 2;
        ctx.strokeRect(
          lastBlock.x - lastBlock.width / 2,
          lastBlock.y - BALANCE.block.height,
          lastBlock.width,
          BALANCE.block.height
        );
      }
      
      // ë–¨ì–´ì§€ëŠ” ì¡°ê° ê·¸ë¦¬ê¸°
      fallingPieces.forEach(p => {
        ctx.globalAlpha = 0.7;
        drawBlock(p.x, p.y, p.width, BALANCE.block.height, p.color, p.rotation);
        ctx.globalAlpha = 1;
      });
      
      ctx.restore();
      
      // íŒŒí‹°í´ ê·¸ë¦¬ê¸° (ì¹´ë©”ë¼ ì˜í–¥ ì•ˆ ë°›ìŒ)
      particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
      
      // íŒŒì›Œì—… í™œì„±í™” íš¨ê³¼
      if (activePowerup) {
        ctx.fillStyle = activePowerup === 'magnet' ? 'rgba(100,200,255,0.1)' :
                       activePowerup === 'slow' ? 'rgba(100,255,100,0.1)' :
                       'rgba(255,215,0,0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // íƒ€ì´ë¨¸ ë°”
        const barWidth = (powerupTimer / 300) * (canvas.width - 40);
        ctx.fillStyle = activePowerup === 'magnet' ? '#64c8ff' :
                       activePowerup === 'slow' ? '#64ff64' : '#ffd700';
        ctx.fillRect(20, canvas.height - 25, barWidth, 5);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ì…ë ¥ ì²˜ë¦¬
    canvas.addEventListener('click', (e) => {
      if (gameState === 'playing') {
        dropBlock();
      }
    });
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameState === 'playing') {
        dropBlock();
      }
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'menu') startGame();
        else if (gameState === 'playing') dropBlock();
        else if (gameState === 'gameover') startGame();
      }
      // ìˆ«ì í‚¤ë¡œ íŒŒì›Œì—…
      if (gameState === 'playing') {
        if (e.code === 'Digit1') activatePowerup('magnet');
        if (e.code === 'Digit2') activatePowerup('slow');
        if (e.code === 'Digit3') activatePowerup('double');
      }
    });
    
    // íŒŒì›Œì—… ë²„íŠ¼ ì´ë²¤íŠ¸
    document.getElementById('pwMagnet').addEventListener('click', (e) => {
      e.stopPropagation();
      activatePowerup('magnet');
    });
    document.getElementById('pwSlow').addEventListener('click', (e) => {
      e.stopPropagation();
      activatePowerup('slow');
    });
    document.getElementById('pwDouble').addEventListener('click', (e) => {
      e.stopPropagation();
      activatePowerup('double');
    });

    // ì´ˆê¸°í™”
    init();
    gameLoop();
  </script>
</body>
</html>
