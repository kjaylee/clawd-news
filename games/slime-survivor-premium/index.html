<!DOCTYPE html>
<html lang="en">
<head>
    <script data-goatcounter="https://jaygames.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f0f1a">
    <title>ğŸŸ¢ Slime Survivor PREMIUM</title>
<meta property="og:title" content="ğŸŸ¢ Slime Survivor PREMIUM">
<meta property="og:type" content="website">
<meta property="og:url" content="https://eastsea.monster/games/slime-survivor-premium/">
<meta property="og:description" content="Play Slime Survivor Premium - Free HTML5 game. No download required!">
<meta property="og:image" content="https://eastsea.monster/games/slime-survivor-premium/og.png">
<meta property="og:site_name" content="East Sea Games">
<meta name="description" content="Play Slime Survivor Premium - Free HTML5 browser game. No download, no install.">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eastsea.monster/games/slime-survivor-premium/og.png">
<meta name="twitter:title" content="ğŸŸ¢ Slime Survivor PREMIUM">
    <meta name="description" content="Ultimate pixel-art survivor roguelike. Survive endless waves, level up, unlock weapons, and compete on the leaderboard!">
    <!--
        ============================================
        ğŸŸ¢ ìŠ¬ë¼ì„ ì„œë°”ì´ë²„ PREMIUM EDITION
        ============================================
        Original: ìŠ¬ë¼ì„ ì„œë°”ì´ë²„ (Pixel Art Edition)
        Premium upgrade: Full progression, sound, effects, leaderboard, daily challenge
        
        ì—ì…‹ ì¶œì²˜ (Asset Credits):
        - Art/UI: ê²Œì„ë§ˆë‹¹ (í•œêµ­ì½˜í…ì¸ ì§„í¥ì› Â· KOCCA)
        - ì‚¬ìš´ë“œ/BGM: ê²Œì„ë§ˆë‹¹ (í•œêµ­ì½˜í…ì¸ ì§„í¥ì› Â· KOCCA)
        - ìºë¦­í„°/ì : Canvas API í”„ë¡œì‹œì €ëŸ´ ìƒì„±
        - ë¼ì´ì„ ìŠ¤: MIT (ì½”ë“œ), ê²Œì„ë§ˆë‹¹ ì´ìš©ì•½ê´€ (ì—ì…‹)
        ============================================
    -->
    <style>
        :root {
            --neon-green: #00ff88;
            --neon-blue: #00ccff;
            --neon-purple: #bb44ff;
            --neon-gold: #ffd700;
            --neon-red: #ff4466;
            --bg-dark: #0f0f1a;
            --bg-card: rgba(20, 20, 40, 0.95);
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        body {
            background: var(--bg-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: var(--tg-viewport-height, 100vh);
            min-height: 100dvh;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden;
            touch-action: manipulation;
            color: #fff;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            max-width: 800px;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
        }
        /* HUD */
        #hud {
            position: absolute;
            top: var(--safe-top, 8px);
            left: 8px;
            right: 8px;
            padding-top: 8px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 50;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 4px; }
        .hud-stat {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0,0,0,0.9), 2px 2px 4px #000;
            line-height: 1.3;
        }
        #xpBarOuter {
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.6);
            border-radius: 3px;
            position: absolute;
            top: calc(var(--safe-top, 8px) + 52px);
            left: 0;
            z-index: 50;
        }
        #xpBarInner {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), #00ffcc);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 8px var(--neon-green);
        }
        /* Virtual Joystick */
        #joystickZone {
            position: absolute;
            bottom: var(--safe-bottom, 0px);
            left: 0;
            width: 100%;
            height: 50%;
            z-index: 60;
            pointer-events: none;
            touch-action: none;
        }
        #joystickZone.active {
            pointer-events: auto;
        }
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,136,0.15), rgba(0,255,136,0.05));
            border: 2px solid rgba(0,255,136,0.25);
            display: none;
        }
        #joystickThumb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,136,0.5), rgba(0,255,136,0.2));
            border: 2px solid rgba(0,255,136,0.6);
            display: none;
        }
        /* Screens */
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-card);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 200;
            transition: opacity 0.4s ease;
            padding: 10px 16px;
            overflow-y: auto;
            touch-action: auto;
            -webkit-overflow-scrolling: touch;
        }
        .screen-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .screen-title {
            font-size: clamp(1.5rem, 5vw, 2.8rem);
            margin-bottom: 4px;
            text-shadow: 0 0 30px var(--neon-green), 0 0 60px var(--neon-green);
            animation: titlePulse 2s infinite;
        }
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }
        .screen-subtitle {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 8px;
        }
        .btn {
            padding: 12px 30px;
            font-size: 1rem;
            border-image: url('assets/gui/btn_green.png') 21 20 21 20 fill / 16px / 0 stretch;
            background: none;
            border-radius: 0;
            cursor: pointer;
            color: #111;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: inherit;
            min-width: 180px;
            pointer-events: auto;
        }
        .btn:active { transform: scale(0.95); }
        @media (hover: hover) {
            .btn:hover { box-shadow: 0 0 30px rgba(0,255,136,0.5); transform: scale(1.03); }
        }
        .btn-secondary {
            border-image: none;
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 30px;
        }
        .btn-daily {
            border-image: url('assets/gui/btn_yellow.png') 21 20 21 20 fill / 16px / 0 stretch;
            background: none;
            color: #111;
        }
        .btn-share {
            background: linear-gradient(135deg, var(--neon-purple), #ff44aa);
            color: #fff;
        }
        .btn-row { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; margin: 6px 0; }
        /* Meta Stats */
        .meta-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin: 6px 0;
            width: 100%;
            max-width: 360px;
        }
        .meta-stat {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 8px 4px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .meta-stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--neon-green);
        }
        .meta-stat-label {
            font-size: 0.65rem;
            color: #888;
            margin-top: 1px;
        }
        /* Character Select */
        .char-select {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 4px 0;
        }
        .char-card {
            width: 65px;
            padding: 8px 4px;
            background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        .char-card.selected {
            border-color: var(--neon-green);
            box-shadow: 0 0 15px rgba(0,255,136,0.3);
            background: rgba(0,255,136,0.08);
        }
        .char-card.locked {
            opacity: 0.4;
            pointer-events: none;
        }
        .char-card:active { transform: scale(0.95); }
        .char-icon { font-size: 1.5rem; }
        .char-name { font-size: 0.65rem; margin-top: 4px; color: #ccc; }
        .char-req { font-size: 0.55rem; color: var(--neon-gold); margin-top: 2px; }
        /* Upgrade Screen */
        #upgradeScreen {
            z-index: 300;
        }
        .upgrade-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95%;
        }
        .upgrade-card {
            padding: 16px 12px;
            width: 140px;
            background: linear-gradient(135deg, rgba(30,30,60,0.95), rgba(40,40,80,0.95));
            border: 2px solid var(--neon-green);
            border-radius: 15px;
            cursor: pointer;
            color: #fff;
            text-align: center;
            transition: all 0.2s;
        }
        .upgrade-card:active { transform: scale(0.95); background: rgba(0,255,136,0.15); }
        @media (hover: hover) {
            .upgrade-card:hover { box-shadow: 0 0 20px rgba(0,255,136,0.4); transform: scale(1.03); }
        }
        .upgrade-icon { font-size: 2rem; margin-bottom: 8px; }
        .upgrade-name { font-size: 0.9rem; color: var(--neon-green); font-weight: bold; }
        .upgrade-desc { font-size: 0.75rem; color: #aaa; margin-top: 4px; }
        .upgrade-tier { font-size: 0.65rem; color: var(--neon-gold); margin-top: 4px; }
        /* Leaderboard */
        .leaderboard {
            width: 100%;
            max-width: 360px;
            margin: 10px 0;
        }
        .lb-entry {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin: 3px 0;
            font-size: 0.85rem;
        }
        .lb-entry.highlight {
            background: rgba(0,255,136,0.1);
            border: 1px solid rgba(0,255,136,0.3);
        }
        .lb-rank { width: 30px; font-weight: bold; color: var(--neon-gold); }
        .lb-name { flex: 1; }
        .lb-score { color: var(--neon-green); font-weight: bold; }
        .lb-date { color: #666; font-size: 0.7rem; margin-left: 8px; }
        /* Game Over Stats */
        .go-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 12px 0;
            width: 100%;
            max-width: 300px;
        }
        .go-stat {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 10px;
            text-align: center;
        }
        .go-stat-val { font-size: 1.2rem; font-weight: bold; }
        .go-stat-label { font-size: 0.7rem; color: #888; }
        /* Daily Challenge Badge */
        .daily-badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, var(--neon-gold), #ff9900);
            color: #111;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: bold;
            margin: 5px 0;
        }
        .daily-modifier {
            font-size: 0.8rem;
            color: var(--neon-gold);
            margin: 6px 0;
            padding: 8px;
            background: rgba(255,215,0,0.08);
            border-radius: 8px;
            border: 1px solid rgba(255,215,0,0.15);
        }
        /* Toast notifications */
        #toastContainer {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            pointer-events: none;
        }
        .toast {
            padding: 8px 20px;
            background: var(--bg-card);
            border: 1px solid var(--neon-green);
            border-radius: 20px;
            font-size: 0.85rem;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 2.5s forwards;
            white-space: nowrap;
        }
        @keyframes toastIn { from { opacity:0; transform:translateY(-20px); } to { opacity:1; transform:translateY(0); } }
        @keyframes toastOut { from { opacity:1; } to { opacity:0; transform:translateY(-10px); } }
        /* Scrollbar */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 2px; }
        /* Pause button */
        #pauseBtn {
            position: absolute;
            top: var(--safe-top, 8px);
            right: 8px;
            padding: 8px;
            min-width: 44px;
            min-height: 44px;
            background: rgba(0,0,0,0.5);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            z-index: 55;
            pointer-events: auto;
            line-height: 1;
        }
        #pauseBtn:active { transform: scale(0.9); }
        /* Mute FAB */
        #muteFab {
            position: absolute;
            bottom: calc(var(--safe-bottom, 0px) + 16px);
            right: 16px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.15);
            color: #fff;
            font-size: 22px;
            cursor: pointer;
            z-index: 55;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            transition: transform 0.2s, background 0.2s;
            line-height: 1;
        }
        #muteFab:active { transform: scale(0.85); }
        #muteFab.muted { background: rgba(255,0,0,0.3); border-color: rgba(255,68,102,0.4); }
        /* Combo text overlay */
        #comboTextOverlay {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,100,0,0.8), 0 0 40px rgba(255,50,0,0.5), 2px 4px 8px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 80;
            opacity: 0;
            transition: none;
            white-space: nowrap;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }
        @keyframes comboTextPop {
            0% { opacity:0; transform: translate(-50%,-50%) scale(0.3) rotate(-5deg); }
            15% { opacity:1; transform: translate(-50%,-50%) scale(1.3) rotate(2deg); }
            30% { transform: translate(-50%,-50%) scale(1) rotate(0deg); }
            80% { opacity:1; }
            100% { opacity:0; transform: translate(-50%,-50%) scale(0.8) translateY(-30px); }
        }
        #comboTextOverlay.active {
            animation: comboTextPop 1.5s ease-out forwards;
        }
        /* Boss entrance overlay */
        #bossEntrance {
            position: absolute;
            inset: 0;
            z-index: 90;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #bossEntrance.active { opacity: 1; }
        #bossEntrance .boss-dim {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.6);
        }
        #bossEntrance .boss-banner {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        #bossEntrance .boss-warn {
            font-size: clamp(1.5rem, 6vw, 3rem);
            font-weight: 900;
            color: #ff4444;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            animation: bossPulse 0.4s ease-in-out infinite alternate;
            letter-spacing: 3px;
            font-family: 'Courier New', monospace;
        }
        #bossEntrance .boss-name {
            margin-top: 12px;
            font-size: clamp(1rem, 4vw, 1.8rem);
            color: #ffd700;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,215,0,0.6);
            opacity: 0;
            animation: bossNameFade 0.5s 0.6s ease forwards;
        }
        @keyframes bossPulse {
            from { transform: scale(1); text-shadow: 0 0 20px #ff0000; }
            to { transform: scale(1.05); text-shadow: 0 0 40px #ff0000, 0 0 60px #ff4400; }
        }
        @keyframes bossNameFade {
            from { opacity:0; transform: translateY(10px); }
            to { opacity:1; transform: translateY(0); }
        }
        /* Scanlines for boss entrance */
        #bossEntrance .boss-scanlines {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(255,0,0,0.03) 2px,
                rgba(255,0,0,0.03) 4px
            );
            animation: scanScroll 0.5s linear infinite;
        }
        @keyframes scanScroll {
            from { transform: translateY(0); }
            to { transform: translateY(4px); }
        }

        /* ============ Loading Screen ============ */
        #loadingScreen { position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#0f0f1a 0%,#1a1a3a 50%,#0f0f1a 100%); transition:opacity .6s ease; }
        #loadingScreen.fade-out { opacity:0; pointer-events:none; }
        .loading-content { text-align:center; padding:30px; }
        .loading-icon { font-size:4em; animation:titlePulse 2s ease-in-out infinite; }
        .loading-title { font-size:1.8em; font-weight:900; color:var(--neon-green); margin:12px 0; text-shadow:0 0 20px var(--neon-green),0 0 40px var(--neon-green); }
        .loading-bar { width:220px; height:8px; background:rgba(255,255,255,.1); border-radius:4px; overflow:hidden; margin:16px auto; }
        .loading-fill { width:0%; height:100%; background:linear-gradient(90deg,var(--neon-green),var(--neon-blue),var(--neon-purple)); border-radius:4px; transition:width .3s ease; }
        .loading-text { font-size:.9em; color:var(--neon-green); font-weight:600; margin-top:4px; }
        .loading-credit { margin-top:24px; font-size:.55em; color:rgba(0,255,136,.4); line-height:1.5; }
        /* Attribution */
        .attribution { position:fixed; bottom:2px; left:0; right:0; text-align:center; font-size:.5em; color:rgba(0,255,136,.25); pointer-events:none; z-index:5; }
        /* Upgrade Sprite */
        .upgrade-sprite { width:52px; height:52px; border-radius:10px; object-fit:cover; margin-bottom:6px; filter:drop-shadow(0 0 6px rgba(0,255,136,.4)); }
        /* === Real Asset Icons === */
        .hud-icon { width:16px; height:16px; vertical-align:middle; margin-right:2px; filter:brightness(1.2); image-rendering:auto; }
        .btn-icon { width:20px; height:20px; vertical-align:middle; margin-right:4px; filter:brightness(1.1); }
        .title-icon { width:32px; height:32px; vertical-align:middle; margin-right:6px; filter:drop-shadow(0 0 8px rgba(0,255,136,0.5)); }
        .char-icon-img { width:36px; height:36px; image-rendering:auto; filter:drop-shadow(0 0 4px rgba(255,255,255,0.3)); }
        .upgrade-icon-img { width:52px; height:52px; border-radius:10px; filter:drop-shadow(0 0 6px rgba(0,255,136,.4)); margin-bottom:6px; }
        .loading-icon-img { width:64px; height:64px; animation:titlePulse 2s ease-in-out infinite; filter:drop-shadow(0 0 12px rgba(0,255,136,0.6)); }
        .medal-icon { width:20px; height:20px; vertical-align:middle; }
        .stat-icon { width:18px; height:18px; vertical-align:middle; margin-right:2px; }
        .fab-icon { width:24px; height:24px; filter:brightness(1.3); }
        .pause-icon { width:22px; height:22px; filter:brightness(1.3); }
    </style>
    <!-- Telegram Mini App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/telegram-miniapp/public/tg-bridge.js"></script>
<script src="../i18n.js"></script>
    <!-- Telegram Mini App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/games/tg-sdk-wrapper.js?v=1769736738"></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "ìŠ¬ë¼ì„ ì„œë°”ì´ë²„ PREMIUM",
  "url": "https://eastsea.monster/games/slime-survivor-premium/",
  "description": "â­ í”Œë˜ê·¸ì‹­! ë±€ì„œë¼ì´í¬ í”„ë¦¬ë¯¸ì—„ ì—ë””ì…˜ â€” í”„ë¡œê·¸ë ˆì…˜, ìºë¦­í„° í•´ê¸ˆ, ë³´ìŠ¤, ë°ì¼ë¦¬ ì±Œë¦°ì§€, ì‚¬ìš´ë“œ, ë¦¬ë”ë³´ë“œ, ê³µìœ  ê¸°ëŠ¥ê¹Œì§€!",
  "image": "https://eastsea.monster/games/slime-survivor-premium/og.png",
  "gamePlatform": [
    "Web Browser",
    "Mobile Browser"
  ],
  "applicationCategory": "Game",
  "genre": "Action",
  "operatingSystem": "Any",
  "inLanguage": [
    "ko",
    "en"
  ],
  "playMode": "SinglePlayer",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD",
    "availability": "https://schema.org/InStock"
  },
  "author": {
    "@type": "Person",
    "name": "Jay Lee",
    "url": "https://eastsea.monster"
  }
}
</script>
</head>
<body>
<!-- Loading Screen -->
<div id="loadingScreen">
  <div class="loading-content">
    <div class="loading-icon"><img class="loading-icon-img" src="assets/icons/char_gem_green.png" alt=""></div>
    <div class="loading-title">ìŠ¬ë¼ì„ ì„œë°”ì´ë²„</div>
    <div style="font-size:.75rem;color:var(--neon-gold);margin-bottom:12px;"><img class="stat-icon" src="assets/icons/ui_star.png" alt=""> PREMIUM EDITION <img class="stat-icon" src="assets/icons/ui_star.png" alt=""></div>
    <div class="loading-bar"><div class="loading-fill" id="loadFill"></div></div>
    <div class="loading-text" id="loadText">Loading...</div>
    <div class="loading-credit">Skills: 2000 Fantasy Icons Â· SFX: Epic Toon FX + Cute UI<br>Music: Fantasy Music Pack 2</div>
  </div>
</div>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <div class="hud-stat"><img class="hud-icon" src="assets/icons/hud_timer.png" alt=""> <span id="hudTime">0:00</span></div>
            <div class="hud-stat"><img class="hud-icon" src="assets/icons/hud_kills.png" alt=""> <span id="hudKills">0</span></div>
            <div class="hud-stat"><img class="hud-icon" src="assets/icons/hud_level.png" alt=""> Lv.<span id="hudLevel">1</span></div>
        </div>
        <div class="hud-right">
            <div class="hud-stat" style="text-align:right"><img class="hud-icon" src="assets/icons/hud_score.png" alt=""> <span id="hudScore">0</span></div>
            <div class="hud-stat" style="text-align:right;color:var(--neon-gold)"><img class="hud-icon" src="assets/icons/hud_coins.png" alt=""> <span id="hudCoins">0</span></div>
        </div>
    </div>
    <div id="xpBarOuter"><div id="xpBarInner"></div></div>
    <button id="pauseBtn" style="display:none;"><img class="pause-icon" src="assets/icons/ui_pause.png" alt="pause"></button>
    <button id="muteFab" onclick="toggleMuteFab()"><img class="fab-icon" id="muteFabIcon" src="assets/icons/ui_sound.png" alt="sound"></button>

    <!-- Combo Text Overlay -->
    <div id="comboTextOverlay"></div>

    <!-- Boss Entrance Overlay -->
    <div id="bossEntrance">
        <div class="boss-dim"></div>
        <div class="boss-scanlines"></div>
        <div class="boss-banner">
            <div class="boss-warn"><img class="btn-icon" src="assets/icons/ui_shield_magic.png" alt=""> BOSS INCOMING <img class="btn-icon" src="assets/icons/ui_shield_magic.png" alt=""></div>
            <div class="boss-name" id="bossNamePlate"><img class="btn-icon" src="assets/icons/ui_skull.png" alt=""> SKULL LORD</div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer"></div>

    <!-- Virtual Joystick -->
    <div id="joystickZone">
        <div id="joystickBase"></div>
        <div id="joystickThumb"></div>
    </div>

    <!-- START SCREEN -->
    <div id="startScreen" class="screen-overlay">
        <div class="screen-title"><img class="title-icon" src="assets/icons/char_gem_green.png" alt=""> ìŠ¬ë¼ì„ ì„œë°”ì´ë²„</div>
        <div style="font-size:0.75rem;color:var(--neon-gold);margin-bottom:12px;"><img class="stat-icon" src="assets/icons/ui_star.png" alt=""> PREMIUM EDITION <img class="stat-icon" src="assets/icons/ui_star.png" alt=""></div>
        <div class="meta-stats" id="metaStats"></div>
        <div style="font-size:0.8rem;margin:8px 0;color:#aaa;">ìºë¦­í„° ì„ íƒ</div>
        <div class="char-select" id="charSelect"></div>
        <div class="btn-row">
            <button class="btn" onclick="startNormalGame()"><img class="btn-icon" src="assets/icons/ui_gamepad.png" alt=""> ê²Œì„ ì‹œì‘</button>
        </div>
        <div class="btn-row">
            <button class="btn btn-daily" onclick="startDailyChallenge()" id="dailyBtn"><img class="btn-icon" src="assets/icons/ui_calendar.png" alt=""> ë°ì¼ë¦¬ ì±Œë¦°ì§€</button>
            <button class="btn btn-secondary" onclick="showLeaderboard()"><img class="btn-icon" src="assets/icons/ui_trophy.png" alt=""> ë¦¬ë”ë³´ë“œ</button>
        </div>
        <div style="font-size:0.75rem;opacity:0.5;margin-top:12px;"><img class="hud-icon" src="assets/icons/upg_boot.png" alt=""> ë§ˆìš°ìŠ¤/í„°ì¹˜ë¡œ ì´ë™ Â· <img class="hud-icon" src="assets/icons/upg_sword.png" alt=""> ìë™ ê³µê²©</div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameOverScreen" class="screen-overlay hidden">
        <div class="screen-title" style="font-size:clamp(1.5rem,4vw,2.2rem);"><img class="title-icon" src="assets/icons/ui_skull.png" alt=""> ê²Œì„ ì˜¤ë²„</div>
        <div id="goNewRecord" style="display:none;color:var(--neon-gold);font-weight:bold;margin:4px 0;"><img class="stat-icon" src="assets/icons/ui_crown.png" alt=""> NEW RECORD!</div>
        <div id="goDailyBadge" class="daily-badge" style="display:none;"><img class="stat-icon" src="assets/icons/ui_calendar.png" alt=""> ë°ì¼ë¦¬ ì±Œë¦°ì§€</div>
        <div class="go-stats" id="goStats"></div>
        <div class="btn-row">
            <button class="btn" onclick="restartGame()" id="i18nRetry"><img class="btn-icon" src="assets/icons/ui_refresh.png" alt=""> Retry</button>
            <button class="btn btn-share" onclick="shareScore()"><img class="btn-icon" src="assets/icons/ui_share.png" alt=""> ê³µìœ í•˜ê¸°</button>
        </div>
        <div class="btn-row">
            <button class="btn btn-secondary" onclick="showLeaderboard()"><img class="btn-icon" src="assets/icons/ui_trophy.png" alt=""> ë¦¬ë”ë³´ë“œ</button>
            <button class="btn btn-secondary" onclick="goToMenu()"><img class="btn-icon" src="assets/icons/ui_home.png" alt=""> ë©”ë‰´</button>
        </div>
    </div>

    <!-- LEADERBOARD SCREEN -->
    <div id="leaderboardScreen" class="screen-overlay hidden">
        <div class="screen-title" style="font-size:1.5rem;"><img class="title-icon" src="assets/icons/ui_trophy.png" alt=""> ë¦¬ë”ë³´ë“œ</div>
        <div class="btn-row" style="margin:8px 0;">
            <button class="btn btn-secondary" style="padding:8px 16px;font-size:0.8rem;min-width:auto;" onclick="switchLB('normal')" id="lbTabNormal">ì¼ë°˜</button>
            <button class="btn btn-secondary" style="padding:8px 16px;font-size:0.8rem;min-width:auto;" onclick="switchLB('daily')" id="lbTabDaily">ë°ì¼ë¦¬</button>
        </div>
        <div class="leaderboard" id="lbContent"></div>
        <button class="btn btn-secondary" onclick="closeLB()" style="margin-top:12px;">ë‹«ê¸°</button>
    </div>

    <!-- UPGRADE SCREEN -->
    <div id="upgradeScreen" class="screen-overlay hidden">
        <div style="font-size:1.3rem;color:var(--neon-green);font-weight:bold;margin-bottom:4px;"><img class="btn-icon" src="assets/icons/ui_levelup.png" alt=""> ë ˆë²¨ ì—…!</div>
        <div style="font-size:0.8rem;color:#888;margin-bottom:12px;">ì—…ê·¸ë ˆì´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
        <div class="upgrade-options" id="upgradeOptions"></div>
    </div>

    <!-- PAUSE SCREEN -->
    <div id="pauseScreen" class="screen-overlay hidden">
        <div class="screen-title" style="font-size:1.5rem;"><img class="title-icon" src="assets/icons/ui_pause.png" alt=""> ì¼ì‹œì •ì§€</div>
        <div class="btn-row" style="flex-direction:column;">
            <button class="btn" onclick="resumeGame()"><img class="btn-icon" src="assets/icons/ui_play.png" alt=""> ê³„ì†í•˜ê¸°</button>
            <button class="btn btn-secondary" onclick="toggleSound()"><img class="btn-icon" id="soundToggleIcon" src="assets/icons/ui_sound.png" alt=""> ì‚¬ìš´ë“œ: <span id="soundToggle">ON</span></button>
            <button class="btn btn-secondary" onclick="goToMenu()"><img class="btn-icon" src="assets/icons/ui_home.png" alt=""> ë©”ë‰´ë¡œ</button>
        </div>
    </div>
</div>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”Š SOUND SYSTEM (Real Audio Assets)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SKILL_SPRITES = {};
const UPGRADE_SPRITE_MAP = {
    'âš”ï¸':'skill_1','ğŸ”¥':'skill_4','ğŸ‘Ÿ':'skill_7','â¤ï¸':'skill_8',
    'ğŸ”®':'skill_3','ğŸŒ€':'skill_2','ğŸ“':'skill_2','ğŸ’«':'skill_7',
    'ğŸ§²':'skill_6','ğŸ’š':'skill_5','ğŸ’¥':'skill_1','ğŸ›¡ï¸':'skill_5'
};
// Real asset icon paths for upgrades (emoji â†’ PNG)
const UPGRADE_ICON_MAP = {
    'âš”ï¸':'assets/icons/upg_sword.png',
    'ğŸ”¥':'assets/icons/upg_fire.png',
    'ğŸ‘Ÿ':'assets/icons/upg_boot.png',
    'â¤ï¸':'assets/icons/upg_heart.png',
    'ğŸ”®':'assets/icons/upg_crystal.png',
    'ğŸŒ€':'assets/icons/upg_orbital.png',
    'ğŸ“':'assets/icons/upg_range.png',
    'ğŸ’«':'assets/icons/upg_star.png',
    'ğŸ§²':'assets/icons/upg_magnet.png',
    'ğŸ’š':'assets/icons/upg_regen.png',
    'ğŸ’¥':'assets/icons/upg_crit.png',
    'ğŸ›¡ï¸':'assets/icons/upg_shield.png',
};
// Character icon map (index â†’ PNG)
const CHAR_ICON_MAP = [
    'assets/icons/char_gem_green.png',
    'assets/icons/char_gem_red.png',
    'assets/icons/char_gem_blue.png',
    'assets/icons/char_gem_purple.png',
    'assets/icons/char_crown.png',
];

const AudioManager = {
    ctx: null, enabled: true, masterGain: null, sfxGain: null,
    bgmGain: null, bgmPlaying: false, bgmSource: null, buffers: {},
    _xpPickupCounter: 0,

    init() {
        if (this.ctx) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3;
            this.masterGain.connect(this.ctx.destination);
            this.sfxGain = this.ctx.createGain();
            this.sfxGain.gain.value = 1.0;
            this.sfxGain.connect(this.masterGain);
            this.bgmGain = this.ctx.createGain();
            this.bgmGain.gain.value = 0.35;
            this.bgmGain.connect(this.masterGain);
        } catch(e) { this.enabled = false; }
    },

    async _loadBuf(name, url) {
        try {
            const r = await fetch(url);
            const ab = await r.arrayBuffer();
            this.buffers[name] = await this.ctx.decodeAudioData(ab);
        } catch(e) { console.warn('Audio load fail:', name, e); }
    },

    async preload(onProgress) {
        this.init();
        const m = {
            shoot:'assets/audio/shoot.mp3', hit:'assets/audio/hit.mp3',
            death:'assets/audio/death.mp3', levelup:'assets/audio/levelup.mp3',
            pickup:'assets/audio/pickup.mp3', click:'assets/audio/click.mp3',
            select:'assets/audio/select.mp3', merge:'assets/audio/merge.mp3',
            bgm:'assets/audio/bgm.mp3'
        };
        const entries = Object.entries(m);
        let n = 0;
        for (const [k, v] of entries) {
            await this._loadBuf(k, v);
            n++;
            if (onProgress) onProgress(n, entries.length);
        }
    },

    resume() {
        if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
    },

    toggle() {
        this.enabled = !this.enabled;
        if (this.masterGain) this.masterGain.gain.value = this.enabled ? 0.3 : 0;
        document.getElementById('soundToggle').textContent = this.enabled ? 'ON' : 'OFF';
        const fabIcon = document.getElementById('muteFabIcon');
        if (fabIcon) fabIcon.src = this.enabled ? 'assets/icons/ui_sound.png' : 'assets/icons/ui_mute.png';
        const fab = document.getElementById('muteFab');
        if (fab) fab.classList.toggle('muted', !this.enabled);
        const toggleIcon = document.getElementById('soundToggleIcon');
        if (toggleIcon) toggleIcon.src = this.enabled ? 'assets/icons/ui_sound.png' : 'assets/icons/ui_mute.png';
    },

    _playBuf(name, vol, rate) {
        if (!this.enabled || !this.ctx || !this.buffers[name]) return;
        try {
            const s = this.ctx.createBufferSource();
            const g = this.ctx.createGain();
            s.buffer = this.buffers[name];
            s.playbackRate.value = rate || 1.0;
            g.gain.value = vol || 0.5;
            s.connect(g); g.connect(this.sfxGain);
            s.start(0);
        } catch(e) {}
    },

    // BGM (real mp3 loop)
    startBGM() {
        if (this.bgmPlaying || !this.ctx || !this.buffers.bgm) return;
        this.bgmPlaying = true;
        this.bgmSource = this.ctx.createBufferSource();
        this.bgmSource.buffer = this.buffers.bgm;
        this.bgmSource.loop = true;
        this.bgmSource.connect(this.bgmGain);
        this.bgmSource.start(0);
    },

    stopBGM() {
        this.bgmPlaying = false;
        if (this.bgmSource) { try { this.bgmSource.stop(); } catch(e) {} this.bgmSource = null; }
    },

    // SFX â€” all using real .ogg files
    shootEnergy()    { this._playBuf('shoot', 0.35, 1.1); },
    shootFire()      { this._playBuf('shoot', 0.4, 0.8); },
    orbitalHum()     { this._playBuf('hit', 0.08, 0.5); },
    hit()            { this._playBuf('hit', 0.5); },
    kill()           { this._playBuf('death', 0.5); },
    pickup() {
        this._xpPickupCounter++;
        const rate = 1.0 + Math.min(this._xpPickupCounter * 0.05, 0.5);
        this._playBuf('pickup', 0.4, rate);
        clearTimeout(this._xpResetTimer);
        this._xpResetTimer = setTimeout(() => { this._xpPickupCounter = 0; }, 500);
    },
    coinPickup()     { this._playBuf('pickup', 0.35, 1.3); },
    levelUp()        { this._playBuf('levelup', 0.6); },
    gameOver()       { this._playBuf('death', 0.7, 0.6); },
    bossAlert()      { this._playBuf('merge', 0.6, 0.7); },
    achievement()    { this._playBuf('levelup', 0.5, 1.2); },
    comboMilestone() { this._playBuf('merge', 0.5); },
    shoot()          { this.shootEnergy(); }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¾ PROGRESSION SYSTEM (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SAVE_KEY = 'slime_survivor_premium_v2';

const Progression = {
    data: null,

    defaults() {
        return {
            metaLevel: 1,
            metaXp: 0,
            totalCoins: 0,
            totalKills: 0,
            totalRuns: 0,
            bestTime: 0,
            bestKills: 0,
            bestLevel: 0,
            bestScore: 0,
            selectedChar: 0,
            unlockedChars: [true, false, false, false, false],
            permUpgrades: { damage: 0, speed: 0, hp: 0, xpGain: 0, coinGain: 0 },
            achievements: {},
            dailyCompleted: null,
            dailyBestScore: 0,
        };
    },

    load() {
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            this.data = raw ? { ...this.defaults(), ...JSON.parse(raw) } : this.defaults();
        } catch(e) { this.data = this.defaults(); }
    },

    save() {
        try { localStorage.setItem(SAVE_KEY, JSON.stringify(this.data)); } catch(e) {}
    },

    addXp(amount) {
        this.data.metaXp += amount;
        const needed = this.metaXpNeeded();
        if (this.data.metaXp >= needed) {
            this.data.metaXp -= needed;
            this.data.metaLevel++;
            this.checkUnlocks();
            return true;
        }
        return false;
    },

    metaXpNeeded() {
        return 50 + this.data.metaLevel * 30;
    },

    checkUnlocks() {
        const lv = this.data.metaLevel;
        if (lv >= 3 && !this.data.unlockedChars[1]) { this.data.unlockedChars[1] = true; showToast('íŒŒì´ì–´ ìŠ¬ë¼ì„ í•´ê¸ˆ!'); }
        if (lv >= 6 && !this.data.unlockedChars[2]) { this.data.unlockedChars[2] = true; showToast('ì•„ì´ìŠ¤ ìŠ¬ë¼ì„ í•´ê¸ˆ!'); }
        if (lv >= 10 && !this.data.unlockedChars[3]) { this.data.unlockedChars[3] = true; showToast('ë‹¤í¬ ìŠ¬ë¼ì„ í•´ê¸ˆ!'); }
        if (lv >= 15 && !this.data.unlockedChars[4]) { this.data.unlockedChars[4] = true; showToast('ê³¨ë“œ ìŠ¬ë¼ì„ í•´ê¸ˆ!'); }
    },

    permBonus(stat) {
        return this.data.permUpgrades[stat] || 0;
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ† LEADERBOARD SYSTEM (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LB_KEY = 'slime_survivor_lb_v2';
const LB_DAILY_KEY = 'slime_survivor_lb_daily_v2';

const Leaderboard = {
    getEntries(key = LB_KEY) {
        try { return JSON.parse(localStorage.getItem(key)) || []; } catch(e) { return []; }
    },

    addEntry(entry, key = LB_KEY) {
        const entries = this.getEntries(key);
        entries.push(entry);
        entries.sort((a, b) => b.score - a.score);
        const trimmed = entries.slice(0, 20);
        try { localStorage.setItem(key, JSON.stringify(trimmed)); } catch(e) {}
        return trimmed.findIndex(e => e === entry) + 1;
    },

    isNewRecord(score, key = LB_KEY) {
        const entries = this.getEntries(key);
        return entries.length < 20 || score > (entries[entries.length - 1]?.score || 0);
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“… DAILY CHALLENGE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DailyChallenge = {
    getSeed() {
        const d = new Date();
        return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
    },

    getDateStr() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    },

    seededRandom(seed) {
        let s = seed;
        return () => { s = (s * 1103515245 + 12345) & 0x7fffffff; return s / 0x7fffffff; };
    },

    getModifiers() {
        const seed = this.getSeed();
        const rng = this.seededRandom(seed);

        const modifierPool = [
            { name: 'ìŠ¤í”¼ë“œëŸ°', desc: 'ì  ì†ë„ 2ë°°, ì ìˆ˜ 1.5ë°°', enemySpeedMult: 2, scoreMult: 1.5 },
            { name: 'ë¯¸ë‹ˆê±´', desc: 'ê³µì† 2ë°°, ë°ë¯¸ì§€ ì ˆë°˜', fireRateMult: 0.5, damageMult: 0.5 },
            { name: 'íƒ±ì»¤ ëª¨ë“œ', desc: 'HP 3ë°°, ì´ë™ì†ë„ ì ˆë°˜', hpMult: 3, speedMult: 0.5 },
            { name: 'ì˜¤ë¹„íƒˆ ë§ˆìŠ¤í„°', desc: 'ì˜¤ë¹„íƒˆ 3ê°œ ì‹œì‘', startOrbitals: 3 },
            { name: 'í•˜ë“œì½”ì–´', desc: 'HP ì ˆë°˜, ì ìˆ˜ 2ë°°', hpMult: 0.5, scoreMult: 2 },
            { name: 'ìŠ¤ë‚˜ì´í¼', desc: 'ê³µì† ì ˆë°˜, ë°ë¯¸ì§€ 3ë°°, ê´€í†µ+2', fireRateMult: 2, damageMult: 3, startPiercing: 2 },
            { name: 'ìŠ¤í”„ë¦°í„°', desc: 'ì´ë™ì†ë„ 2ë°°, HP ì ˆë°˜', speedMult: 2, hpMult: 0.5 },
            { name: 'ê³¨ë“œëŸ¬ì‹œ', desc: 'ì½”ì¸ 3ë°°, ì  ê°•í™”', coinMult: 3, enemyHpMult: 1.5 },
        ];

        const idx = Math.floor(rng() * modifierPool.length);
        return modifierPool[idx];
    },

    isCompleted() {
        return Progression.data.dailyCompleted === this.getDateStr();
    }
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ SPRITE SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const sprites = {};
const SPRITE_SIZE = 32;

function createSpriteFromPixels(pixels, colors, scale = 2) {
    const size = pixels.length;
    const c = document.createElement('canvas');
    c.width = size * scale;
    c.height = size * scale;
    const cx = c.getContext('2d');
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const ci = pixels[y][x];
            if (ci > 0 && colors[ci]) {
                cx.fillStyle = colors[ci];
                cx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }
    return c;
}

// Characters definition
const CHARACTERS = [
    { name: 'ìŠ¬ë¼ì„', icon: 'ğŸŸ¢', desc: 'ê¸°ë³¸', reqLevel: 1,
      mainColor: '#44cc44', highlightColor: '#88ff88', darkColor: '#1a5c1a', midColor: '#2d8a2d', glowColor: '#00ff88',
      bonuses: {} },
    { name: 'íŒŒì´ì–´', icon: 'ğŸ”´', desc: 'Lv.3', reqLevel: 3,
      mainColor: '#ff4444', highlightColor: '#ff8888', darkColor: '#8b0000', midColor: '#cc2222', glowColor: '#ff4400',
      bonuses: { damage: 3 } },
    { name: 'ì•„ì´ìŠ¤', icon: 'ğŸ”µ', desc: 'Lv.6', reqLevel: 6,
      mainColor: '#4488ff', highlightColor: '#88bbff', darkColor: '#002288', midColor: '#2266cc', glowColor: '#00ccff',
      bonuses: { speed: 0.5 } },
    { name: 'ë‹¤í¬', icon: 'ğŸŸ£', desc: 'Lv.10', reqLevel: 10,
      mainColor: '#bb44ff', highlightColor: '#dd88ff', darkColor: '#440088', midColor: '#8822cc', glowColor: '#bb44ff',
      bonuses: { hp: 20, damage: 2 } },
    { name: 'ê³¨ë“œ', icon: 'ğŸŸ¡', desc: 'Lv.15', reqLevel: 15,
      mainColor: '#ffcc00', highlightColor: '#ffee88', darkColor: '#886600', midColor: '#ccaa00', glowColor: '#ffd700',
      bonuses: { coinGain: 2, xpGain: 1 } },
];

function createCharSprites(charDef) {
    const colors = {
        1: charDef.darkColor, 2: charDef.midColor, 3: charDef.mainColor, 4: charDef.highlightColor,
        5: '#ffffff', 6: '#000000', 7: charDef.highlightColor,
    };
    const frames = [
        [
            [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0],
            [0,0,1,2,3,3,3,3,3,3,3,3,2,1,0,0],
            [0,1,2,3,3,4,4,3,3,4,4,3,3,2,1,0],
            [0,1,3,3,4,7,7,4,4,7,7,4,3,3,1,0],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,3,5,5,5,3,3,3,5,5,5,3,3,2,1],
            [1,2,3,5,6,5,3,3,3,5,6,5,3,3,2,1],
            [1,2,3,5,5,5,3,3,3,5,5,5,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [0,1,2,3,3,3,3,3,3,3,3,3,3,2,1,0],
            [0,1,2,2,3,3,3,3,3,3,3,3,2,2,1,0],
            [0,0,1,2,2,2,3,3,3,3,2,2,2,1,0,0],
            [0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
        ],
        [
            [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0],
            [0,0,0,1,2,3,3,3,3,3,3,2,1,0,0,0],
            [0,0,1,2,3,3,4,4,4,4,3,3,2,1,0,0],
            [0,1,2,3,3,4,7,4,4,7,4,3,3,2,1,0],
            [0,1,2,3,3,3,3,3,3,3,3,3,3,2,1,0],
            [1,2,3,5,5,5,3,3,3,5,5,5,3,3,2,1],
            [1,2,3,5,6,5,3,3,3,5,6,5,3,3,2,1],
            [1,2,3,5,5,5,3,3,3,5,5,5,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,2,3,3,3,3,3,3,3,3,3,3,2,2,1],
            [0,1,2,2,3,3,3,3,3,3,3,3,2,2,1,0],
            [0,1,1,2,2,2,3,3,3,3,2,2,2,1,1,0],
            [0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
        ],
    ];
    return frames.map(f => createSpriteFromPixels(f, colors, 2));
}

function createEnemySprites() {
    const result = {};
    const makeSlime = (colors) => {
        const px = [
            [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,2,2,2,2,2,2,2,2,1,0,0,0],
            [0,0,1,2,3,3,3,3,3,3,3,3,2,1,0,0],
            [0,1,2,3,3,4,4,3,3,4,4,3,3,2,1,0],
            [0,1,2,3,4,7,7,4,4,7,7,4,3,2,1,0],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,3,5,5,3,3,3,3,3,5,5,3,3,2,1],
            [1,2,3,5,6,5,3,3,3,5,6,5,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [1,2,3,3,3,3,3,3,3,3,3,3,3,3,2,1],
            [0,1,2,3,3,3,3,3,3,3,3,3,3,2,1,0],
            [0,1,2,2,2,3,3,3,3,3,3,2,2,2,1,0],
            [0,0,1,1,2,2,2,2,2,2,2,2,1,1,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];
        return createSpriteFromPixels(px, colors, 2);
    };
    result.redSlime = makeSlime({1:'#8b0000',2:'#cc2222',3:'#ff4444',4:'#ff8888',5:'#fff',6:'#000',7:'#ffaaaa'});
    result.orangeSlime = makeSlime({1:'#8b4500',2:'#cc6600',3:'#ff8800',4:'#ffaa44',5:'#fff',6:'#000',7:'#ffcc88'});
    result.purpleSlime = makeSlime({1:'#4b0082',2:'#8b008b',3:'#ff00ff',4:'#ff88ff',5:'#fff',6:'#000',7:'#ffaaff'});
    result.blueSlime = makeSlime({1:'#002266',2:'#0044aa',3:'#0088ff',4:'#44aaff',5:'#fff',6:'#000',7:'#88ccff'});

    // Skull (elite)
    const skullPx = [
        [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,0,1,1,3,3,3,3,3,3,1,1,0,0,0],
        [0,0,1,3,4,4,4,4,4,4,4,4,3,1,0,0],
        [0,1,3,4,5,5,5,4,4,5,5,5,4,3,1,0],
        [0,1,3,4,5,6,5,4,4,5,6,5,4,3,1,0],
        [0,1,3,4,5,5,5,4,4,5,5,5,4,3,1,0],
        [1,2,3,4,4,4,4,4,4,4,4,4,4,3,2,1],
        [1,2,3,4,4,4,4,4,4,4,4,4,4,3,2,1],
        [1,2,3,4,4,4,1,4,4,1,4,4,4,3,2,1],
        [0,1,3,4,4,4,4,1,1,4,4,4,4,3,1,0],
        [0,1,2,3,4,4,4,4,4,4,4,4,3,2,1,0],
        [0,0,1,2,3,3,1,1,1,1,3,3,2,1,0,0],
        [0,0,0,1,1,2,2,2,2,2,2,1,1,0,0,0],
        [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    ];
    result.skull = createSpriteFromPixels(skullPx, {1:'#333',2:'#666',3:'#999',4:'#ccc',5:'#fff',6:'#000',7:'#f00'}, 2);

    // Bat
    const batPx = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
        [2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2],
        [3,2,1,1,0,0,1,1,1,1,0,0,1,1,2,3],
        [3,3,2,1,1,1,2,2,2,2,1,1,1,2,3,3],
        [0,3,3,2,2,2,3,3,3,3,2,2,2,3,3,0],
        [0,0,3,3,3,3,5,3,3,5,3,3,3,3,0,0],
        [0,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0],
        [0,0,0,0,3,3,3,6,6,3,3,3,0,0,0,0],
        [0,0,0,0,0,2,3,3,3,3,2,0,0,0,0,0],
        [0,0,0,0,0,0,1,2,2,1,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    ];
    result.bat = createSpriteFromPixels(batPx, {1:'#1a1a2e',2:'#2a2a4e',3:'#4a4a6e',4:'#6a6a8e',5:'#ff0000',6:'#ffff00'}, 2);

    // Boss skull (bigger, red glow)
    result.boss = createSpriteFromPixels(skullPx, {1:'#660000',2:'#990000',3:'#cc0000',4:'#ff4444',5:'#ffffff',6:'#ffff00',7:'#ff0000'}, 3);

    return result;
}

function createBulletSprites() {
    const px = [
        [0,0,0,1,1,1,1,0,0,0],
        [0,0,1,2,2,2,2,1,0,0],
        [0,1,2,3,3,3,3,2,1,0],
        [1,2,3,4,4,4,4,3,2,1],
        [1,2,3,4,5,5,4,3,2,1],
        [1,2,3,4,5,5,4,3,2,1],
        [1,2,3,4,4,4,4,3,2,1],
        [0,1,2,3,3,3,3,2,1,0],
        [0,0,1,2,2,2,2,1,0,0],
        [0,0,0,1,1,1,1,0,0,0],
    ];
    return {
        energy: createSpriteFromPixels(px, {1:'#004466',2:'#0088cc',3:'#00ccff',4:'#88ffff',5:'#ffffff'}, 2),
        orbital: createSpriteFromPixels(px, {1:'#663300',2:'#cc6600',3:'#ff9900',4:'#ffcc00',5:'#ffff88'}, 2),
        fire: createSpriteFromPixels(px, {1:'#660000',2:'#cc2200',3:'#ff4400',4:'#ff8844',5:'#ffcc88'}, 2),
    };
}

function createXpOrbSprite() {
    const px = [
        [0,0,0,0,1,1,0,0,0,0],
        [0,0,1,1,2,2,1,1,0,0],
        [0,1,2,3,3,3,3,2,1,0],
        [0,1,3,4,4,5,4,3,1,0],
        [1,2,3,4,5,6,5,3,2,1],
        [1,2,3,5,6,6,5,3,2,1],
        [0,1,3,4,5,5,4,3,1,0],
        [0,1,2,3,4,4,3,2,1,0],
        [0,0,1,1,2,2,1,1,0,0],
        [0,0,0,0,1,1,0,0,0,0],
    ];
    return createSpriteFromPixels(px, {1:'#004400',2:'#008800',3:'#00cc00',4:'#00ff00',5:'#88ff88',6:'#ffffff'}, 2);
}

function createCoinSprite() {
    const px = [
        [0,0,0,1,1,1,1,0,0,0],
        [0,0,1,2,2,3,2,1,0,0],
        [0,1,2,3,4,4,3,2,1,0],
        [1,2,3,4,5,5,4,3,2,1],
        [1,2,3,4,5,5,4,3,2,1],
        [1,2,3,4,5,5,4,3,2,1],
        [1,2,3,4,4,4,4,3,2,1],
        [0,1,2,3,3,3,3,2,1,0],
        [0,0,1,2,2,2,2,1,0,0],
        [0,0,0,1,1,1,1,0,0,0],
    ];
    return createSpriteFromPixels(px, {1:'#886600',2:'#aa8800',3:'#ccaa00',4:'#ffcc00',5:'#ffee88'}, 2);
}

function initSprites() {
    sprites.enemies = createEnemySprites();
    sprites.bullets = createBulletSprites();
    sprites.xpOrb = createXpOrbSprite();
    sprites.coin = createCoinSprite();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ® GAME ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H, dpr;

function resizeCanvas() {
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    W = gameContainer.clientWidth;
    H = gameContainer.clientHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
const gameContainer = document.getElementById('gameContainer');
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Detect mobile
const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || ('ontouchstart' in window);

// â”€â”€ Game State â”€â”€
let game = null;
let player = null;
let weapons = null;
let bullets = [], enemies = [], xpOrbs = [], coins = [], particles = [], damageNumbers = [], screenEffects = [];
let orbitAngle = 0;
let spawnTimer = 0;
let bossTimer = 0;
let lastTime = 0;
let isDaily = false;
let dailyModifiers = null;
let selectedCharIdx = 0;
let currentCharSprites = null;
let screenShake = { x: 0, y: 0, intensity: 0 };
let screenFlash = { alpha: 0, color: '#fff' };
let comboCount = 0, comboTimer = 0;
let totalScore = 0, runCoins = 0;

// Juice systems
let slowMotion = { active: false, timer: 0, scale: 1, zoom: 1 };
let comboText = { active: false, text: '', timer: 0 };
let bossEntranceActive = false;
let killStreak = 0, killStreakTimer = 0; // for massacre/unstoppable tracking

// â”€â”€ Input â”€â”€
let inputDir = { x: 0, y: 0 };
let joystickActive = false;
let joystickStartX = 0, joystickStartY = 0;
const joystickBase = document.getElementById('joystickBase');
const joystickThumb = document.getElementById('joystickThumb');
const joystickZone = document.getElementById('joystickZone');

if (isMobile) {
    joystickZone.addEventListener('touchstart', (e) => {
        if (!game || !game.running || game.paused) return;
        e.preventDefault();
        AudioManager.resume();
        const t = e.touches[0];
        joystickActive = true;
        joystickStartX = t.clientX;
        joystickStartY = t.clientY;
        joystickBase.style.display = 'block';
        joystickBase.style.left = (t.clientX - 60) + 'px';
        joystickBase.style.top = (t.clientY - 60) + 'px';
        joystickThumb.style.display = 'block';
        joystickThumb.style.left = (t.clientX - 25) + 'px';
        joystickThumb.style.top = (t.clientY - 25) + 'px';
    }, { passive: false });

    joystickZone.addEventListener('touchmove', (e) => {
        if (!joystickActive) return;
        e.preventDefault();
        const t = e.touches[0];
        let dx = t.clientX - joystickStartX;
        let dy = t.clientY - joystickStartY;
        const dist = Math.hypot(dx, dy);
        const maxDist = 50;
        if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
        joystickThumb.style.left = (joystickStartX + dx - 25) + 'px';
        joystickThumb.style.top = (joystickStartY + dy - 25) + 'px';
        inputDir.x = dx / maxDist;
        inputDir.y = dy / maxDist;
    }, { passive: false });

    const endJoystick = () => {
        joystickActive = false;
        inputDir.x = 0;
        inputDir.y = 0;
        joystickBase.style.display = 'none';
        joystickThumb.style.display = 'none';
    };
    joystickZone.addEventListener('touchend', endJoystick);
    joystickZone.addEventListener('touchcancel', endJoystick);
} else {
    // Desktop: mouse follow
    joystickZone.style.display = 'none';
    let mouseTarget = { x: W / 2, y: H / 2 };
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseTarget.x = e.clientX - rect.left;
        mouseTarget.y = e.clientY - rect.top;
    });
    // Update inputDir from mouse position each frame
    window._mouseTarget = mouseTarget;
}

// Pause button
document.getElementById('pauseBtn').addEventListener('click', () => {
    AudioManager.resume();
    if (game && game.running && !game.paused) pauseGame();
});

// â”€â”€ Upgrade Options (with tiers) â”€â”€
function getUpgradePool() {
    return [
        { icon:'âš”ï¸', name:'ê³µê²©ë ¥', desc:'+5 ë°ë¯¸ì§€', tier:()=>Math.floor(weapons.main.damage/10),
          apply:()=>{ weapons.main.damage += 5; } },
        { icon:'ğŸ”¥', name:'ê³µì†', desc:'ê³µê²© ì†ë„ +20%', tier:()=>Math.floor((500-weapons.main.fireRate)/50),
          apply:()=>{ weapons.main.fireRate = Math.max(80, weapons.main.fireRate * 0.8); } },
        { icon:'ğŸ‘Ÿ', name:'ì´ë™ì†ë„', desc:'+0.5 ì†ë„', tier:()=>Math.floor((player.speed-3)/0.5),
          apply:()=>{ player.speed += 0.5; } },
        { icon:'â¤ï¸', name:'ì²´ë ¥', desc:'+30 ìµœëŒ€HP', tier:()=>Math.floor((player.maxHp-100)/30),
          apply:()=>{ player.maxHp += 30; player.hp = Math.min(player.hp + 30, player.maxHp); } },
        { icon:'ğŸ”®', name:'ê´€í†µ', desc:'+1 ê´€í†µ', tier:()=>weapons.main.piercing,
          apply:()=>{ weapons.main.piercing += 1; } },
        { icon:'ğŸŒ€', name:'ì˜¤ë¹„íƒˆ', desc:'ê¶¤ë„ ë¬´ê¸° +1', tier:()=>weapons.orbitals.count,
          apply:()=>{ weapons.orbitals.count = Math.min(8, weapons.orbitals.count + 1); } },
        { icon:'ğŸ“', name:'ê¶¤ë„ ë²”ìœ„', desc:'+20 ë°˜ê²½', tier:()=>Math.floor((weapons.orbitals.radius-60)/20),
          apply:()=>{ weapons.orbitals.radius += 20; } },
        { icon:'ğŸ’«', name:'ê¶¤ë„ ì†ë„', desc:'+50% íšŒì „', tier:()=>Math.floor(Math.log2(weapons.orbitals.speed/0.03)),
          apply:()=>{ weapons.orbitals.speed *= 1.5; } },
        { icon:'ğŸ§²', name:'ìì„', desc:'ìˆ˜ì§‘ ë²”ìœ„ +30', tier:()=>Math.floor((player.magnetRange-120)/30),
          apply:()=>{ player.magnetRange += 30; } },
        { icon:'ğŸ’š', name:'íšŒë³µ', desc:'HP ì¬ìƒ +1/s', tier:()=>Math.floor(player.regen),
          apply:()=>{ player.regen += 1; } },
        { icon:'ğŸ’¥', name:'í¬ë¦¬í‹°ì»¬', desc:'ì¹˜ëª…íƒ€ +10%', tier:()=>Math.floor(weapons.main.critChance/0.1),
          apply:()=>{ weapons.main.critChance = Math.min(0.8, weapons.main.critChance + 0.1); } },
        { icon:'ğŸ›¡ï¸', name:'ë°©ì–´ë ¥', desc:'í”¼í•´ -2', tier:()=>player.armor,
          apply:()=>{ player.armor += 2; } },
    ];
}

// â”€â”€ Spawn System â”€â”€
function getEnemyTypes() {
    const spdM = (dailyModifiers?.enemySpeedMult || 1);
    const hpM = (dailyModifiers?.enemyHpMult || 1);
    return [
        { radius:14, speed:1.5*spdM, hp:20*hpM, sprite:'redSlime', xp:3, coins:1, weight:40 },
        { radius:18, speed:0.8*spdM, hp:50*hpM, sprite:'orangeSlime', xp:8, coins:2, weight:20 },
        { radius:10, speed:2.5*spdM, hp:10*hpM, sprite:'purpleSlime', xp:2, coins:1, weight:25 },
        { radius:14, speed:1.2*spdM, hp:30*hpM, sprite:'skull', xp:5, coins:2, weight:10 },
        { radius:12, speed:2.0*spdM, hp:15*hpM, sprite:'bat', xp:4, coins:1, weight:15 },
        { radius:16, speed:1.0*spdM, hp:40*hpM, sprite:'blueSlime', xp:6, coins:2, weight:10 },
    ];
}

function weightedRandom(items) {
    const total = items.reduce((s, i) => s + i.weight, 0);
    let r = Math.random() * total;
    for (const item of items) {
        r -= item.weight;
        if (r <= 0) return item;
    }
    return items[0];
}

function spawnEnemy() {
    const side = Math.floor(Math.random() * 4);
    let x, y;
    switch(side) {
        case 0: x = Math.random() * W; y = -30; break;
        case 1: x = W + 30; y = Math.random() * H; break;
        case 2: x = Math.random() * W; y = H + 30; break;
        case 3: x = -30; y = Math.random() * H; break;
    }
    const type = weightedRandom(getEnemyTypes());
    const diffMult = 1 + (game.time / 60) * 0.4;
    enemies.push({
        x, y, radius: type.radius, speed: type.speed * (1 + Math.random()*0.3),
        hp: type.hp * diffMult, maxHp: type.hp * diffMult,
        sprite: type.sprite, xp: type.xp, coins: type.coins,
        flash: 0, isBoss: false
    });
}

function spawnBoss() {
    // Cinematic boss entrance
    bossEntranceActive = true;
    AudioManager.bossAlert();
    screenShake.intensity = 8;

    // Boss name variety based on wave
    const bossWave = Math.floor(game.time / 90) + 1;
    const bossNames = ['SKULL LORD', 'MEGA SLIME', 'INFERNO KING', 'FROST TITAN', 'STORM BRINGER'];
    const bossName = bossNames[(bossWave - 1) % bossNames.length];
    const namePlate = document.getElementById('bossNamePlate');
    if (namePlate) namePlate.textContent = bossName;

    // Show boss entrance overlay
    const entrance = document.getElementById('bossEntrance');
    entrance.classList.add('active');

    // Dim BGM during entrance
    if (AudioManager.bgmGain) {
        AudioManager.bgmGain.gain.setValueAtTime(0.1, AudioManager.ctx.currentTime);
    }

    // After entrance animation, spawn the boss
    setTimeout(() => {
        entrance.classList.remove('active');
        bossEntranceActive = false;
        // Restore BGM
        if (AudioManager.bgmGain) {
            AudioManager.bgmGain.gain.setValueAtTime(0.35, AudioManager.ctx.currentTime);
        }
        screenFlash = { alpha: 0.5, color: '#ff0000' };
        screenShake.intensity = 15;

        const diffMult = 1 + (game.time / 60) * 0.5;
        enemies.push({
            x: Math.random() * W, y: -50,
            radius: 30, speed: 0.6, hp: 500 * diffMult, maxHp: 500 * diffMult,
            sprite: 'boss', xp: 50, coins: 20,
            flash: 0, isBoss: true
        });
    }, 1800);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ GAME FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initGame(daily = false) {
    isDaily = daily;
    dailyModifiers = daily ? DailyChallenge.getModifiers() : null;
    const charDef = CHARACTERS[Progression.data.selectedChar || 0];
    currentCharSprites = createCharSprites(charDef);

    const permDmg = Progression.permBonus('damage') + (charDef.bonuses.damage || 0);
    const permSpd = Progression.permBonus('speed') + (charDef.bonuses.speed || 0);
    const permHp = Progression.permBonus('hp') + (charDef.bonuses.hp || 0);
    const permXp = Progression.permBonus('xpGain') + (charDef.bonuses.xpGain || 0);

    game = {
        running: true, paused: false, time: 0, kills: 0, level: 1,
        xp: 0, xpToLevel: 10, animFrame: 0, animTimer: 0,
        xpMult: 1 + permXp * 0.1,
        coinMult: 1 + (Progression.permBonus('coinGain') + (charDef.bonuses.coinGain || 0)) * 0.1,
        scoreMult: dailyModifiers?.scoreMult || 1,
    };
    if (dailyModifiers?.coinMult) game.coinMult *= dailyModifiers.coinMult;

    const baseHp = 100 + permHp * 5;
    const hpMult = dailyModifiers?.hpMult || 1;
    const spdMult = dailyModifiers?.speedMult || 1;

    player = {
        x: W / 2, y: H / 2, radius: 16,
        speed: (3 + permSpd * 0.3) * spdMult,
        hp: baseHp * hpMult, maxHp: baseHp * hpMult,
        invincible: 0, magnetRange: 120, regen: 0, armor: 0
    };

    const baseDmg = 10 + permDmg * 2;
    const frMult = dailyModifiers?.fireRateMult || 1;
    const dmgMult = dailyModifiers?.damageMult || 1;

    weapons = {
        main: {
            damage: baseDmg * dmgMult, fireRate: 500 * frMult, bulletSpeed: 8,
            bulletSize: 10, lastFired: 0, piercing: dailyModifiers?.startPiercing || 0,
            critChance: 0
        },
        orbitals: {
            count: dailyModifiers?.startOrbitals || 0,
            damage: 15, radius: 60, speed: 0.03
        }
    };

    bullets = []; enemies = []; xpOrbs = []; coins = [];
    particles = []; damageNumbers = []; screenEffects = [];
    orbitAngle = 0; spawnTimer = 0; bossTimer = 0;
    comboCount = 0; comboTimer = 0;
    totalScore = 0; runCoins = 0;
    inputDir = { x: 0, y: 0 };
    screenShake = { x: 0, y: 0, intensity: 0 };
    screenFlash = { alpha: 0, color: '#fff' };
    // Reset juice systems
    slowMotion = { active: false, timer: 0, scale: 1, zoom: 1 };
    comboText = { active: false, text: '', timer: 0 };
    killStreak = 0; killStreakTimer = 0;
    bossEntranceActive = false;
    const ctOverlay = document.getElementById('comboTextOverlay');
    if (ctOverlay) ctOverlay.classList.remove('active');
    const bossEnt = document.getElementById('bossEntrance');
    if (bossEnt) bossEnt.classList.remove('active');
}

function setJoystickEnabled(on) {
    if (isMobile && joystickZone) {
        joystickZone.classList.toggle('active', on);
    }
}

function startNormalGame() {
    AudioManager.init();
    AudioManager.resume();
    initGame(false);
    hideAllScreens();
    setJoystickEnabled(true);
    document.getElementById('pauseBtn').style.display = 'block';
    showMuteFab(true);
    AudioManager.startBGM();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function startDailyChallenge() {
    AudioManager.init();
    AudioManager.resume();
    initGame(true);
    hideAllScreens();
    setJoystickEnabled(true);
    document.getElementById('pauseBtn').style.display = 'block';
    showMuteFab(true);
    AudioManager.startBGM();
    lastTime = performance.now();
    showToast(`ë°ì¼ë¦¬: ${dailyModifiers.name}`);
    requestAnimationFrame(gameLoop);
}

function restartGame() {
    hideAllScreens();
    if (isDaily) startDailyChallenge();
    else startNormalGame();
}

function pauseGame() {
    if (!game || !game.running) return;
    game.paused = true;
    setJoystickEnabled(false);
    document.getElementById('pauseScreen').classList.remove('hidden');
}

function resumeGame() {
    if (!game) return;
    game.paused = false;
    setJoystickEnabled(true);
    document.getElementById('pauseScreen').classList.add('hidden');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function toggleSound() { AudioManager.toggle(); }

function toggleMuteFab() {
    AudioManager.resume();
    AudioManager.toggle();
}

function showMuteFab(show) {
    const fab = document.getElementById('muteFab');
    if (fab) fab.style.display = show ? 'flex' : 'none';
}

function goToMenu() {
    if (game) game.running = false;
    AudioManager.stopBGM();
    hideAllScreens();
    setJoystickEnabled(false);
    document.getElementById('pauseBtn').style.display = 'none';
    showMuteFab(false);
    buildStartScreen();
    document.getElementById('startScreen').classList.remove('hidden');
}

function hideAllScreens() {
    ['startScreen','gameOverScreen','leaderboardScreen','upgradeScreen','pauseScreen'].forEach(id => {
        document.getElementById(id).classList.add('hidden');
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”„ GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function gameLoop(timestamp) {
    if (!game || !game.running) return;
    const rawDelta = (timestamp - lastTime) / 1000;
    let delta = Math.min(rawDelta, 0.05);
    lastTime = timestamp;

    // Slow-motion processing (always ticks, even when game paused for visual effect)
    if (slowMotion.active) {
        slowMotion.timer -= rawDelta;
        if (slowMotion.timer <= 0) {
            slowMotion.active = false;
            slowMotion.scale = 1;
            slowMotion.zoom = 1;
        } else {
            // Ease out of slow-mo
            const t = slowMotion.timer / 0.3;
            slowMotion.scale = 0.15 + (1 - 0.15) * (1 - t);
            slowMotion.zoom = 1 + 0.05 * t;
        }
        delta *= slowMotion.scale;
    }

    if (!game.paused) {
        game.time += delta;
        game.animTimer += delta;
        if (game.animTimer > 0.2) { game.animFrame = (game.animFrame + 1) % 2; game.animTimer = 0; }
        update(delta);
    }
    render();
    updateHUD();
    requestAnimationFrame(gameLoop);
}

function update(delta) {
    // Player movement
    if (!isMobile && window._mouseTarget) {
        const mx = window._mouseTarget.x;
        const my = window._mouseTarget.y;
        const dx = mx - player.x;
        const dy = my - player.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 5) {
            inputDir.x = dx / dist;
            inputDir.y = dy / dist;
        } else {
            inputDir.x = 0;
            inputDir.y = 0;
        }
    }

    const moveLen = Math.hypot(inputDir.x, inputDir.y);
    if (moveLen > 0.1) {
        const nx = inputDir.x / Math.max(moveLen, 1);
        const ny = inputDir.y / Math.max(moveLen, 1);
        player.x += nx * player.speed * (isMobile ? 1.2 : 1);
        player.y += ny * player.speed * (isMobile ? 1.2 : 1);
    }
    player.x = Math.max(player.radius, Math.min(W - player.radius, player.x));
    player.y = Math.max(player.radius, Math.min(H - player.radius, player.y));

    // Invincibility & regen
    if (player.invincible > 0) player.invincible -= delta;
    if (player.regen > 0) {
        player.hp = Math.min(player.maxHp, player.hp + player.regen * delta);
    }

    // Combo timer
    if (comboTimer > 0) {
        comboTimer -= delta;
        if (comboTimer <= 0) comboCount = 0;
    }

    // Kill streak timer (for combo text like MASSACRE, UNSTOPPABLE)
    if (killStreakTimer > 0) {
        killStreakTimer -= delta;
        if (killStreakTimer <= 0) killStreak = 0;
    }

    // Combo text timer
    if (comboText.active) {
        comboText.timer -= delta;
        if (comboText.timer <= 0) comboText.active = false;
    }

    // Spawn
    const spawnRate = Math.max(0.3, 1.5 - game.time / 120);
    spawnTimer += delta;
    if (spawnTimer >= spawnRate) {
        spawnTimer -= spawnRate;
        const count = 1 + Math.floor(game.time / 45);
        for (let i = 0; i < count; i++) spawnEnemy();
    }

    // Boss
    bossTimer += delta;
    if (bossTimer >= 90) {
        bossTimer -= 90;
        spawnBoss();
    }

    // Auto-fire
    fireBullet();

    // Orbitals
    const orbitalKills = [];
    orbitAngle += weapons.orbitals.speed;
    for (let i = 0; i < weapons.orbitals.count; i++) {
        const angle = orbitAngle + (Math.PI * 2 / weapons.orbitals.count) * i;
        const ox = player.x + Math.cos(angle) * weapons.orbitals.radius;
        const oy = player.y + Math.sin(angle) * weapons.orbitals.radius;
        for (const e of enemies) {
            if (e.hp <= 0) continue;
            if (Math.hypot(ox - e.x, oy - e.y) < 15 + e.radius) {
                e.hp -= weapons.orbitals.damage * delta * 60;
                e.flash = 0.08;
                if (Math.random() < 0.3) createParticles(e.x, e.y, '#ffaa00', 1);
                if (e.hp <= 0 && !orbitalKills.includes(e)) {
                    orbitalKills.push(e);
                }
            }
        }
        // Trail particle
        if (Math.random() < 0.3) {
            particles.push({
                x: ox, y: oy,
                vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2,
                life: 0.3, color: '#ff9900', size: 3
            });
        }
    }
    // Process orbital kills (reverse for safe splice)
    for (let i = enemies.length - 1; i >= 0; i--) {
        if (orbitalKills.includes(enemies[i])) {
            killEnemy(enemies[i], i);
        }
    }

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += b.vx;
        b.y += b.vy;
        // Trail
        if (Math.random() < 0.5) {
            particles.push({
                x: b.x, y: b.y,
                vx: (Math.random()-0.5), vy: (Math.random()-0.5),
                life: 0.2, color: b.color || '#00ccff', size: 2
            });
        }
        if (b.x < -30 || b.x > W+30 || b.y < -30 || b.y > H+30) {
            bullets.splice(i, 1);
            continue;
        }
        for (let j = enemies.length - 1; j >= 0; j--) {
            const e = enemies[j];
            if (Math.hypot(b.x - e.x, b.y - e.y) < b.radius + e.radius) {
                let dmg = b.damage;
                let isCrit = false;
                if (Math.random() < weapons.main.critChance) {
                    dmg *= 2;
                    isCrit = true;
                }
                e.hp -= dmg;
                e.flash = 0.1;
                createDmgNumber(e.x, e.y - e.radius, dmg, isCrit ? '#ff4444' : '#ffff00', isCrit);
                createParticles(b.x, b.y, isCrit ? '#ff4444' : '#ffff00', 3);
                AudioManager.hit();

                if (b.piercing > 0) b.piercing--;
                else { bullets.splice(i, 1); }

                if (e.hp <= 0) {
                    killEnemy(e, j);
                }
                break;
            }
        }
    }

    // Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 0) {
            e.x += (dx / dist) * e.speed;
            e.y += (dy / dist) * e.speed;
        }
        if (e.flash > 0) e.flash -= delta;

        if (dist < player.radius + e.radius && player.invincible <= 0) {
            let dmg = Math.max(1, (e.isBoss ? 20 : 10) - player.armor);
            player.hp -= dmg;
            player.invincible = 0.5;
            createParticles(player.x, player.y, '#ff0000', e.isBoss ? 15 : 8);
            createDmgNumber(player.x, player.y - player.radius, dmg, '#ff4444');
            // Stronger screen shake for boss attacks
            screenShake.intensity = e.isBoss ? 18 : 8;
            screenFlash = { alpha: e.isBoss ? 0.5 : 0.3, color: '#ff0000' };
            AudioManager.hit();
            // Boss hit: brief slow-mo for impact feel
            if (e.isBoss && !slowMotion.active) {
                slowMotion.active = true;
                slowMotion.timer = 0.15;
                slowMotion.scale = 0.3;
                slowMotion.zoom = 1.02;
            }
            if (player.hp <= 0) { gameOver(); return; }
        }
    }

    // XP orbs â€” acceleration curve magnet + glow trail
    for (let i = xpOrbs.length - 1; i >= 0; i--) {
        const orb = xpOrbs[i];
        orb.pulse += delta * 5;
        const dist = Math.hypot(orb.x - player.x, orb.y - player.y);
        if (dist < player.magnetRange) {
            // Smooth acceleration curve: faster as orb gets closer
            const t = 1 - (dist / player.magnetRange); // 0 at edge, 1 at center
            const accel = t * t * t; // cubic ease-in
            const spd = 0.05 + accel * 0.5;
            orb.x += (player.x - orb.x) * spd;
            orb.y += (player.y - orb.y) * spd;
            // Glow trail particles when being pulled
            if (Math.random() < 0.3 + accel * 0.5) {
                particles.push({
                    x: orb.x + (Math.random() - 0.5) * 8,
                    y: orb.y + (Math.random() - 0.5) * 8,
                    vx: (player.x - orb.x) * 0.02,
                    vy: (player.y - orb.y) * 0.02,
                    life: 0.2 + accel * 0.3,
                    color: accel > 0.5 ? '#ffffff' : '#88ffaa',
                    size: 2 + accel * 3
                });
            }
        }
        if (dist < player.radius + orb.radius) {
            const gained = Math.floor(orb.xp * game.xpMult);
            game.xp += gained;
            xpOrbs.splice(i, 1);
            createParticles(player.x, player.y, '#00ff88', 3);
            AudioManager.pickup();
            totalScore += gained * 10;
            if (game.xp >= game.xpToLevel) levelUp();
        }
    }

    // Coins
    for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.pulse += delta * 4;
        const dist = Math.hypot(c.x - player.x, c.y - player.y);
        if (dist < player.magnetRange * 0.8) {
            const spd = 0.12 * (1 + (player.magnetRange - dist) / 60);
            c.x += (player.x - c.x) * spd;
            c.y += (player.y - c.y) * spd;
        }
        if (dist < player.radius + 10) {
            const amt = Math.floor(c.value * game.coinMult);
            runCoins += amt;
            coins.splice(i, 1);
            AudioManager.coinPickup();
            createParticles(player.x, player.y, '#ffd700', 2);
        }
        c.life -= delta;
        if (c.life <= 0) coins.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        p.vx *= 0.95; p.vy *= 0.95;
        p.life -= delta;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Damage numbers
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
        const d = damageNumbers[i];
        d.y += d.vy;
        d.vy -= 0.05;
        d.life -= delta * 2;
        if (d.life <= 0) damageNumbers.splice(i, 1);
    }

    // Screen shake decay
    if (screenShake.intensity > 0) {
        screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
        screenShake.intensity *= 0.9;
        if (screenShake.intensity < 0.5) screenShake.intensity = 0;
    }

    // Screen flash decay
    if (screenFlash.alpha > 0) {
        screenFlash.alpha *= 0.92;
        if (screenFlash.alpha < 0.01) screenFlash.alpha = 0;
    }
}

function fireBullet() {
    const now = performance.now();
    if (now - weapons.main.lastFired < weapons.main.fireRate) return;
    let closest = null, closestDist = Infinity;
    for (const e of enemies) {
        const d = Math.hypot(e.x - player.x, e.y - player.y);
        if (d < closestDist) { closestDist = d; closest = e; }
    }
    if (closest && closestDist < 450) {
        const angle = Math.atan2(closest.y - player.y, closest.x - player.x);
        const charDef = CHARACTERS[Progression.data.selectedChar || 0];
        bullets.push({
            x: player.x, y: player.y,
            vx: Math.cos(angle) * weapons.main.bulletSpeed,
            vy: Math.sin(angle) * weapons.main.bulletSpeed,
            radius: weapons.main.bulletSize, damage: weapons.main.damage,
            piercing: weapons.main.piercing,
            color: charDef.glowColor || '#00ccff'
        });
        weapons.main.lastFired = now;
        AudioManager.shoot();
        for (let i = 0; i < 2; i++) {
            particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(angle)*2 + (Math.random()-0.5)*2,
                vy: Math.sin(angle)*2 + (Math.random()-0.5)*2,
                life: 0.3, color: charDef.glowColor || '#00ccff', size: 3
            });
        }
    }
}

function killEnemy(e, idx) {
    // Combo
    comboCount++;
    comboTimer = 2;
    const comboMult = 1 + Math.min(comboCount, 50) * 0.05;

    // Kill streak tracking (for combo text)
    killStreak++;
    killStreakTimer = 1.5;

    // Combo text milestones
    if (killStreak === 10) triggerComboText('ğŸ”¥ KILLING SPREE!', '#ff8800');
    else if (killStreak === 20) triggerComboText('ğŸ’€ MASSACRE!', '#ff4444');
    else if (killStreak === 35) triggerComboText('âš¡ UNSTOPPABLE!', '#ffdd00');
    else if (killStreak === 50) triggerComboText('ğŸ‘‘ GODLIKE!', '#ff00ff');
    else if (killStreak >= 75 && killStreak % 25 === 0) triggerComboText('ğŸŒŸ LEGENDARY!', '#00ffff');

    // Score
    const baseScore = (e.isBoss ? 500 : 50) + e.xp * 10;
    totalScore += Math.floor(baseScore * comboMult * game.scoreMult);

    // Drops
    xpOrbs.push({ x: e.x, y: e.y, xp: e.xp, radius: 10, pulse: 0 });
    if (Math.random() < 0.4 || e.isBoss) {
        const coinCount = e.isBoss ? 5 : 1;
        for (let c = 0; c < coinCount; c++) {
            coins.push({
                x: e.x + (Math.random()-0.5)*20,
                y: e.y + (Math.random()-0.5)*20,
                value: e.coins, pulse: 0, life: 15
            });
        }
    }

    // â”€â”€ Type-specific death particles â”€â”€
    const particleCount = e.isBoss ? 35 : 12;
    const spriteType = e.sprite;

    if (spriteType.includes('Slime') || spriteType === 'boss') {
        // Slime = water droplet / splat particles
        const slimeColors = {
            'redSlime': ['#ff4444','#ff8888','#cc2222'],
            'orangeSlime': ['#ff8800','#ffaa44','#cc6600'],
            'purpleSlime': ['#ff00ff','#ff88ff','#8b008b'],
            'blueSlime': ['#0088ff','#44aaff','#0044aa'],
            'boss': ['#ff4444','#ffd700','#ff0000','#ffff00']
        };
        const colors = slimeColors[spriteType] || ['#44cc44','#88ff88','#1a5c1a'];
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * (e.isBoss ? 8 : 5);
            // Bigger, rounder "droplet" particles
            particles.push({
                x: e.x, y: e.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - Math.random() * 2, // slight upward bias
                life: 0.4 + Math.random() * 0.6,
                color: colors[Math.floor(Math.random() * colors.length)],
                size: (e.isBoss ? 5 : 3) + Math.random() * 4
            });
        }
        // Extra splash ring
        for (let i = 0; i < 6; i++) {
            const angle = (Math.PI * 2 / 6) * i;
            particles.push({
                x: e.x, y: e.y,
                vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3,
                life: 0.3, color: colors[0], size: 2
            });
        }
    } else if (spriteType === 'skull') {
        // Skull = bone fragment particles (white/gray sharp shards)
        const boneColors = ['#ffffff','#cccccc','#999999','#dddddd','#aaaaaa'];
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 5;
            particles.push({
                x: e.x + (Math.random()-0.5) * 10,
                y: e.y + (Math.random()-0.5) * 10,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 1, // upward scatter
                life: 0.5 + Math.random() * 0.7,
                color: boneColors[Math.floor(Math.random() * boneColors.length)],
                size: 2 + Math.random() * 3
            });
        }
        // Dust cloud
        for (let i = 0; i < 5; i++) {
            particles.push({
                x: e.x + (Math.random()-0.5)*15,
                y: e.y + (Math.random()-0.5)*15,
                vx: (Math.random()-0.5)*2, vy: -Math.random()*1.5,
                life: 0.6, color: 'rgba(200,200,200,0.5)', size: 6 + Math.random()*4
            });
        }
    } else if (spriteType === 'bat') {
        // Bat = dark purple wispy particles
        const batColors = ['#4a4a6e','#6a4a8e','#8844aa','#2a2a4e'];
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 1 + Math.random() * 3;
            particles.push({
                x: e.x, y: e.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2, // float upward
                life: 0.6 + Math.random() * 0.8,
                color: batColors[Math.floor(Math.random() * batColors.length)],
                size: 2 + Math.random() * 3
            });
        }
    } else {
        // Fallback generic
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * (e.isBoss ? 8 : 4);
            particles.push({
                x: e.x, y: e.y,
                vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                life: 0.5 + Math.random() * 0.5,
                color: e.isBoss ? `hsl(${Math.random()*60}, 100%, 60%)` : '#ff6600',
                size: e.isBoss ? 6 : 4
            });
        }
    }

    if (e.isBoss) {
        screenShake.intensity = 18;
        screenFlash = { alpha: 0.7, color: '#ffd700' };
        showToast('ğŸ‘‘ BOSS DEFEATED! +500');
        triggerComboText('ğŸ’¥ BOSS SLAIN!', '#ffd700');
    }

    AudioManager.kill();
    enemies.splice(idx, 1);
    game.kills++;

    // Achievements
    checkAchievements();
}

// â”€â”€ Combo Text System â”€â”€
function triggerComboText(text, color) {
    const overlay = document.getElementById('comboTextOverlay');
    if (!overlay) return;
    overlay.textContent = text;
    overlay.style.color = color || '#fff';
    overlay.classList.remove('active');
    // Force reflow to restart animation
    void overlay.offsetWidth;
    overlay.classList.add('active');
    AudioManager.comboMilestone();
    // Extra screen shake for milestone
    screenShake.intensity = Math.max(screenShake.intensity, 10);
    screenFlash = { alpha: 0.3, color: color || '#ffffff' };
}

function levelUp() {
    game.level++;
    game.xp -= game.xpToLevel;
    game.xpToLevel = Math.floor(game.xpToLevel * 1.4);
    AudioManager.levelUp();
    screenFlash = { alpha: 0.5, color: '#00ff88' };
    screenShake.intensity = 8;

    // Slow-motion effect (0.3s)
    slowMotion.active = true;
    slowMotion.timer = 0.3;
    slowMotion.scale = 0.15;
    slowMotion.zoom = 1.05;

    // Pause after slow-mo ends
    setTimeout(() => { game.paused = true; }, 300);

    // Level-up particles
    for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 8;
        particles.push({
            x: player.x, y: player.y,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
            life: 1 + Math.random(), color: `hsl(${Math.random()*60+100},100%,60%)`, size: 5
        });
    }

    // Show upgrade UI
    const pool = getUpgradePool();
    const shuffled = pool.sort(() => Math.random() - 0.5).slice(0, 3);
    const optDiv = document.getElementById('upgradeOptions');
    optDiv.innerHTML = '';
    shuffled.forEach(upg => {
        const tier = Math.max(0, upg.tier());
        const card = document.createElement('div');
        card.className = 'upgrade-card';
        const _iconPath = UPGRADE_ICON_MAP[upg.icon];
        const _sk = UPGRADE_SPRITE_MAP[upg.icon];
        const _si = _iconPath ? '<img class="upgrade-icon-img" src="'+_iconPath+'">' : (_sk && SKILL_SPRITES[_sk] ? '<img class="upgrade-sprite" src="'+SKILL_SPRITES[_sk].src+'">' : '<div class="upgrade-icon">'+upg.icon+'</div>');
        card.innerHTML = `
            ${_si}
            <div class="upgrade-name">${upg.name}</div>
            <div class="upgrade-desc">${upg.desc}</div>
            ${tier > 0 ? `<div class="upgrade-tier">${'â˜…'.repeat(Math.min(tier,5))} Tier ${tier+1}</div>` : ''}
        `;
        card.addEventListener('click', () => {
            AudioManager.pickup();
            upg.apply();
            document.getElementById('upgradeScreen').classList.add('hidden');
            setJoystickEnabled(true);
            game.paused = false;
            lastTime = performance.now();
        });
        optDiv.appendChild(card);
    });
    setJoystickEnabled(false);
    document.getElementById('upgradeScreen').classList.remove('hidden');
}

function gameOver() {
    game.running = false;
    AudioManager.stopBGM();
    AudioManager.gameOver();
    screenShake.intensity = 20;

    // Death explosion
    for (let i = 0; i < 60; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 10;
        particles.push({
            x: player.x, y: player.y,
            vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
            life: 1 + Math.random()*2,
            color: `hsl(${Math.random()*120}, 100%, ${40+Math.random()*30}%)`,
            size: 3 + Math.random() * 5
        });
    }

    // Update progression
    const d = Progression.data;
    d.totalKills += game.kills;
    d.totalRuns++;
    d.totalCoins += runCoins;
    if (game.time > d.bestTime) d.bestTime = game.time;
    if (game.kills > d.bestKills) d.bestKills = game.kills;
    if (game.level > d.bestLevel) d.bestLevel = game.level;
    if (totalScore > d.bestScore) d.bestScore = totalScore;

    // Meta XP
    const metaXpGain = Math.floor(game.time / 10) + Math.floor(game.kills / 5);
    const leveledUp = Progression.addXp(metaXpGain);
    Progression.save();

    // Leaderboard
    const entry = {
        score: totalScore,
        time: game.time,
        kills: game.kills,
        level: game.level,
        date: new Date().toLocaleDateString('ko-KR'),
        char: CHARACTERS[Progression.data.selectedChar || 0].name
    };
    const key = isDaily ? LB_DAILY_KEY : LB_KEY;
    const rank = Leaderboard.addEntry(entry, key);
    const isRecord = rank === 1;

    if (isDaily) {
        Progression.data.dailyCompleted = DailyChallenge.getDateStr();
        if (totalScore > Progression.data.dailyBestScore) Progression.data.dailyBestScore = totalScore;
        Progression.save();
    }

    // Build game over screen
    setTimeout(() => {
        const goStats = document.getElementById('goStats');
        const mins = Math.floor(game.time / 60);
        const secs = Math.floor(game.time % 60);
        goStats.innerHTML = `
            <div class="go-stat"><div class="go-stat-val" style="color:var(--neon-green)">${totalScore.toLocaleString()}</div><div class="go-stat-label">ì ìˆ˜</div></div>
            <div class="go-stat"><div class="go-stat-val">${mins}:${String(secs).padStart(2,'0')}</div><div class="go-stat-label">ìƒì¡´ ì‹œê°„</div></div>
            <div class="go-stat"><div class="go-stat-val" style="color:var(--neon-red)">${game.kills}</div><div class="go-stat-label">ì²˜ì¹˜ ìˆ˜</div></div>
            <div class="go-stat"><div class="go-stat-val" style="color:var(--neon-blue)">Lv.${game.level}</div><div class="go-stat-label">ë„ë‹¬ ë ˆë²¨</div></div>
            <div class="go-stat"><div class="go-stat-val" style="color:var(--neon-gold)"><img class="stat-icon" src="assets/icons/ui_coin.png" alt=""> ${runCoins}</div><div class="go-stat-label">ì½”ì¸</div></div>
            <div class="go-stat"><div class="go-stat-val" style="color:var(--neon-purple)">x${comboCount}</div><div class="go-stat-label">ìµœëŒ€ ì½¤ë³´</div></div>
        `;
        document.getElementById('goNewRecord').style.display = isRecord ? 'block' : 'none';
        document.getElementById('goDailyBadge').style.display = isDaily ? 'block' : 'none';
        if (leveledUp) showToast(`ë©”íƒ€ ë ˆë²¨ ${Progression.data.metaLevel} ë‹¬ì„±!`);
        setJoystickEnabled(false);
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }, 800);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¨ RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function render() {
    ctx.save();
    ctx.translate(screenShake.x, screenShake.y);

    // Slow-motion zoom effect
    if (slowMotion.active && slowMotion.zoom > 1) {
        const z = slowMotion.zoom;
        ctx.translate(W / 2, H / 2);
        ctx.scale(z, z);
        ctx.translate(-W / 2, -H / 2);
    }

    // Background
    ctx.fillStyle = '#0f1020';
    ctx.fillRect(-10, -10, W + 20, H + 20);

    // Grid
    ctx.strokeStyle = 'rgba(40, 80, 120, 0.12)';
    ctx.lineWidth = 1;
    const gridSize = 40;
    for (let x = 0; x < W; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
    }
    for (let y = 0; y < H; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
    }

    // XP orbs
    for (const orb of xpOrbs) {
        const scale = 1 + Math.sin(orb.pulse) * 0.15;
        ctx.save();
        ctx.translate(orb.x, orb.y);
        ctx.scale(scale, scale);
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ff88';
        ctx.drawImage(sprites.xpOrb, -sprites.xpOrb.width/2, -sprites.xpOrb.height/2);
        ctx.restore();
    }

    // Coins
    for (const c of coins) {
        const scale = 1 + Math.sin(c.pulse) * 0.1;
        const alpha = c.life < 3 ? c.life / 3 : 1;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(c.x, c.y);
        ctx.scale(scale, scale);
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ffd700';
        ctx.drawImage(sprites.coin, -sprites.coin.width/2, -sprites.coin.height/2);
        ctx.restore();
    }

    // Enemies
    for (const e of enemies) {
        const sprite = sprites.enemies[e.sprite];
        if (!sprite) continue;

        // HP bar
        const hpR = e.hp / e.maxHp;
        const barW = e.isBoss ? 50 : 30;
        ctx.fillStyle = '#222';
        ctx.fillRect(e.x - barW/2, e.y - e.radius - 14, barW, 5);
        ctx.fillStyle = hpR > 0.5 ? '#00ff00' : hpR > 0.25 ? '#ffff00' : '#ff0000';
        ctx.fillRect(e.x - barW/2, e.y - e.radius - 14, barW * hpR, 5);

        ctx.save();
        ctx.translate(e.x, e.y);
        if (e.flash > 0) ctx.filter = 'brightness(2.5)';
        const sc = e.isBoss ? e.radius / 16 : e.radius / 14;
        ctx.scale(sc, sc);

        // Boss glow
        if (e.isBoss) {
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ff0000';
        }
        ctx.drawImage(sprite, -sprite.width/2, -sprite.height/2);
        ctx.restore();
    }

    // Bullets
    for (const b of bullets) {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.shadowBlur = 12;
        ctx.shadowColor = b.color || '#00ccff';
        const sc = b.radius / 10;
        ctx.scale(sc, sc);
        ctx.drawImage(sprites.bullets.energy, -sprites.bullets.energy.width/2, -sprites.bullets.energy.height/2);
        ctx.restore();
    }

    // Orbital trail & orbitals
    if (weapons && weapons.orbitals.count > 0) {
        ctx.beginPath();
        ctx.arc(player.x, player.y, weapons.orbitals.radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 153, 0, 0.15)';
        ctx.lineWidth = 2;
        ctx.stroke();
        for (let i = 0; i < weapons.orbitals.count; i++) {
            const angle = orbitAngle + (Math.PI * 2 / weapons.orbitals.count) * i;
            const ox = player.x + Math.cos(angle) * weapons.orbitals.radius;
            const oy = player.y + Math.sin(angle) * weapons.orbitals.radius;
            ctx.save();
            ctx.translate(ox, oy);
            ctx.rotate(angle * 2);
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ff9900';
            ctx.drawImage(sprites.bullets.orbital, -sprites.bullets.orbital.width/2, -sprites.bullets.orbital.height/2);
            ctx.restore();
        }
    }

    // Player
    if (player && currentCharSprites) {
        ctx.save();
        ctx.translate(player.x, player.y);
        if (player.invincible > 0 && Math.floor(player.invincible * 10) % 2) ctx.globalAlpha = 0.4;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(0, player.radius - 3, player.radius * 0.9, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Sprite
        const charDef = CHARACTERS[Progression.data.selectedChar || 0];
        ctx.shadowBlur = 20;
        ctx.shadowColor = charDef.glowColor;
        const ps = currentCharSprites[game.animFrame];
        ctx.drawImage(ps, -ps.width/2, -ps.height/2 - 4);
        ctx.restore();

        // HP bar
        const hpR = player.hp / player.maxHp;
        ctx.fillStyle = '#222';
        ctx.fillRect(player.x - 25, player.y - player.radius - 26, 50, 8);
        ctx.fillStyle = hpR > 0.5 ? '#00ff00' : hpR > 0.25 ? '#ffff00' : '#ff0000';
        ctx.fillRect(player.x - 25, player.y - player.radius - 26, 50 * hpR, 8);
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.strokeRect(player.x - 25, player.y - player.radius - 26, 50, 8);
    }

    // Particles
    ctx.shadowBlur = 0;
    for (const p of particles) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, (p.size || 4) * Math.max(0, p.life), 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.shadowBlur = 6;
        ctx.shadowColor = p.color;
        ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    // Damage numbers
    ctx.textAlign = 'center';
    for (const d of damageNumbers) {
        ctx.font = `bold ${d.crit ? 20 : 15}px 'Courier New', monospace`;
        ctx.fillStyle = d.color;
        ctx.globalAlpha = Math.max(0, d.life);
        ctx.shadowBlur = 4;
        ctx.shadowColor = '#000';
        ctx.fillText(d.text, d.x, d.y);
    }
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;

    // Combo display
    if (comboCount >= 5) {
        ctx.save();
        ctx.textAlign = 'center';
        ctx.font = 'bold 18px monospace';
        ctx.fillStyle = `hsl(${comboCount * 10 % 360}, 100%, 60%)`;
        ctx.shadowBlur = 10;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fillText(`ğŸ”¥ ${comboCount}x COMBO`, W / 2, H - 40);
        ctx.restore();
    }

    // Screen flash
    if (screenFlash.alpha > 0) {
        ctx.fillStyle = screenFlash.color;
        ctx.globalAlpha = screenFlash.alpha;
        ctx.fillRect(-10, -10, W + 20, H + 20);
        ctx.globalAlpha = 1;
    }

    ctx.restore();

    // Minimap
    renderMinimap();
}

function renderMinimap() {
    const size = 60;
    const margin = 10;
    const mx = W - size - margin;
    const my = H - size - margin - 30;
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.fillRect(mx, my, size, size);
    ctx.strokeRect(mx, my, size, size);

    // Player dot
    const px = mx + (player.x / W) * size;
    const py = my + (player.y / H) * size;
    ctx.fillStyle = '#00ff88';
    ctx.fillRect(px - 2, py - 2, 4, 4);

    // Enemy dots
    ctx.fillStyle = '#ff4444';
    for (const e of enemies) {
        const ex = mx + Math.max(0, Math.min(1, (e.x / W))) * size;
        const ey = my + Math.max(0, Math.min(1, (e.y / H))) * size;
        ctx.fillRect(ex - 1, ey - 1, e.isBoss ? 3 : 2, e.isBoss ? 3 : 2);
    }
    ctx.restore();
}

function updateHUD() {
    if (!game) return;
    const mins = Math.floor(game.time / 60);
    const secs = Math.floor(game.time % 60);
    document.getElementById('hudTime').textContent = `${mins}:${String(secs).padStart(2,'0')}`;
    document.getElementById('hudKills').textContent = game.kills;
    document.getElementById('hudLevel').textContent = game.level;
    document.getElementById('hudScore').textContent = totalScore.toLocaleString();
    document.getElementById('hudCoins').textContent = runCoins;
    document.getElementById('xpBarInner').style.width = `${(game.xp / game.xpToLevel) * 100}%`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ› ï¸ HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function createParticles(x, y, color, count = 5) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 0.5 + Math.random() * 0.5,
            color, size: 3 + Math.random() * 3
        });
    }
}

function createDmgNumber(x, y, damage, color = '#ffff00', crit = false) {
    damageNumbers.push({
        x: x + (Math.random()-0.5)*10, y,
        text: (crit ? 'ğŸ’¥' : '') + Math.floor(damage),
        life: 1, color, vy: -2, crit
    });
}

function showToast(text) {
    const container = document.getElementById('toastContainer');
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = text;
    container.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ… ACHIEVEMENTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const ACHIEVEMENTS = [
    { id: 'first_blood', name: 'ì²« ì²˜ì¹˜', desc: 'ì²« ì  ì²˜ì¹˜', check: () => game.kills >= 1 },
    { id: 'slayer_100', name: 'í•™ì‚´ì', desc: 'í•œ ê²Œì„ì— 100 ì²˜ì¹˜', check: () => game.kills >= 100 },
    { id: 'slayer_500', name: 'ëŒ€í•™ì‚´', desc: 'í•œ ê²Œì„ì— 500 ì²˜ì¹˜', check: () => game.kills >= 500 },
    { id: 'survivor_60', name: '1ë¶„ ìƒì¡´', desc: '60ì´ˆ ìƒì¡´', check: () => game.time >= 60 },
    { id: 'survivor_300', name: '5ë¶„ ìƒì¡´', desc: '300ì´ˆ ìƒì¡´', check: () => game.time >= 300 },
    { id: 'combo_10', name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', desc: '10 ì—°ì† ì½¤ë³´', check: () => comboCount >= 10 },
    { id: 'combo_50', name: 'ì½¤ë³´ ë ˆì „ë“œ', desc: '50 ì—°ì† ì½¤ë³´', check: () => comboCount >= 50 },
    { id: 'level_10', name: 'ì„±ì¥í†µ', desc: 'ë ˆë²¨ 10 ë‹¬ì„±', check: () => game.level >= 10 },
    { id: 'level_20', name: 'ì´ˆì›”', desc: 'ë ˆë²¨ 20 ë‹¬ì„±', check: () => game.level >= 20 },
    { id: 'boss_kill', name: 'ë³´ìŠ¤ ìŠ¬ë ˆì´ì–´', desc: 'ë³´ìŠ¤ ì²˜ì¹˜', check: () => false }, // checked in killEnemy
    { id: 'score_10k', name: 'ë§Œì ì™•', desc: '10,000ì  ë‹¬ì„±', check: () => totalScore >= 10000 },
    { id: 'score_100k', name: 'ì ìˆ˜ ë§ˆë‹ˆì•„', desc: '100,000ì  ë‹¬ì„±', check: () => totalScore >= 100000 },
];

function checkAchievements() {
    for (const ach of ACHIEVEMENTS) {
        if (Progression.data.achievements[ach.id]) continue;
        let earned = false;
        if (ach.id === 'boss_kill') {
            // Check if last killed enemy was boss (handled separately)
        } else {
            earned = ach.check();
        }
        if (earned) {
            Progression.data.achievements[ach.id] = true;
            Progression.save();
            showToast(`ğŸ… ${ach.name}: ${ach.desc}`);
            AudioManager.achievement();
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¤ SHARE FEATURE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function shareScore() {
    const mins = Math.floor(game.time / 60);
    const secs = Math.floor(game.time % 60);
    const charName = CHARACTERS[Progression.data.selectedChar || 0].name;
    const text = `ğŸŸ¢ ìŠ¬ë¼ì„ ì„œë°”ì´ë²„ PREMIUM\n` +
        `${isDaily ? 'ğŸ“… ë°ì¼ë¦¬ ì±Œë¦°ì§€\n' : ''}` +
        `ğŸ† ì ìˆ˜: ${totalScore.toLocaleString()}\n` +
        `â±ï¸ ìƒì¡´: ${mins}:${String(secs).padStart(2,'0')}\n` +
        `ğŸ’€ ì²˜ì¹˜: ${game.kills}  â­ Lv.${game.level}\n` +
        `ğŸ® ìºë¦­í„°: ${charName}\n` +
        `ğŸ”— https://eastsea.monster/games/slime-survivor-premium/`;

    if (navigator.share) {
        navigator.share({ title: 'ìŠ¬ë¼ì„ ì„œë°”ì´ë²„ PREMIUM', text }).catch(() => {});
    } else if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => showToast('ğŸ“‹ í´ë¦½ë³´ë“œì— ë³µì‚¬ë¨!')).catch(() => {});
    } else {
        prompt('ì ìˆ˜ë¥¼ ê³µìœ í•˜ì„¸ìš”:', text);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ† LEADERBOARD UI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let currentLBTab = 'normal';

function showLeaderboard() {
    hideAllScreens();
    document.getElementById('leaderboardScreen').classList.remove('hidden');
    switchLB(currentLBTab);
}

function switchLB(tab) {
    currentLBTab = tab;
    document.getElementById('lbTabNormal').style.borderColor = tab === 'normal' ? 'var(--neon-green)' : 'rgba(255,255,255,0.2)';
    document.getElementById('lbTabDaily').style.borderColor = tab === 'daily' ? 'var(--neon-gold)' : 'rgba(255,255,255,0.2)';
    const key = tab === 'daily' ? LB_DAILY_KEY : LB_KEY;
    const entries = Leaderboard.getEntries(key);
    const div = document.getElementById('lbContent');

    if (entries.length === 0) {
        div.innerHTML = '<div style="text-align:center;color:#666;padding:20px;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤</div>';
        return;
    }

    const medalIcons = ['assets/icons/ui_medal_gold.png','assets/icons/ui_medal_silver.png','assets/icons/ui_medal_bronze.png'];
    div.innerHTML = entries.slice(0, 10).map((e, i) => `
        <div class="lb-entry ${i === 0 ? 'highlight' : ''}">
            <span class="lb-rank">${i < 3 ? '<img class="medal-icon" src="'+medalIcons[i]+'" alt="">' : (i+1)}</span>
            <span class="lb-name">${e.char || 'ìŠ¬ë¼ì„'} Lv.${e.level}</span>
            <span class="lb-score">${e.score?.toLocaleString() || 0}</span>
            <span class="lb-date">${e.date || ''}</span>
        </div>
    `).join('');
}

function closeLB() {
    document.getElementById('leaderboardScreen').classList.add('hidden');
    if (game && game.running) {
        // Game is still going, don't show menu
    } else {
        buildStartScreen();
        document.getElementById('startScreen').classList.remove('hidden');
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ  START SCREEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildStartScreen() {
    const d = Progression.data;

    // Meta stats
    const metaDiv = document.getElementById('metaStats');
    const mins = Math.floor(d.bestTime / 60);
    const secs = Math.floor(d.bestTime % 60);
    metaDiv.innerHTML = `
        <div class="meta-stat"><div class="meta-stat-value"><img class="stat-icon" src="assets/icons/ui_star.png" alt=""> ${d.metaLevel}</div><div class="meta-stat-label">ë©”íƒ€ ë ˆë²¨</div></div>
        <div class="meta-stat"><div class="meta-stat-value">${d.totalRuns}</div><div class="meta-stat-label">ì´ í”Œë ˆì´</div></div>
        <div class="meta-stat"><div class="meta-stat-value">${d.totalKills}</div><div class="meta-stat-label">ì´ ì²˜ì¹˜</div></div>
        <div class="meta-stat"><div class="meta-stat-value">${d.bestScore.toLocaleString()}</div><div class="meta-stat-label">ìµœê³  ì ìˆ˜</div></div>
        <div class="meta-stat"><div class="meta-stat-value">${mins}:${String(secs).padStart(2,'0')}</div><div class="meta-stat-label">ìµœì¥ ìƒì¡´</div></div>
        <div class="meta-stat"><div class="meta-stat-value"><img class="stat-icon" src="assets/icons/ui_coin.png" alt=""> ${d.totalCoins}</div><div class="meta-stat-label">ì´ ì½”ì¸</div></div>
    `;

    // Character select
    const charDiv = document.getElementById('charSelect');
    charDiv.innerHTML = CHARACTERS.map((ch, i) => {
        const unlocked = d.unlockedChars[i];
        const selected = (d.selectedChar || 0) === i;
        const iconSrc = CHAR_ICON_MAP[i] || 'assets/icons/char_gem_green.png';
        return `
            <div class="char-card ${selected ? 'selected' : ''} ${!unlocked ? 'locked' : ''}" onclick="selectChar(${i})">
                <div class="char-icon"><img class="char-icon-img" src="${iconSrc}" alt="${ch.name}"></div>
                <div class="char-name">${ch.name}</div>
                ${!unlocked ? `<div class="char-req"><img class="hud-icon" src="assets/icons/ui_lock.png" alt="lock"> Lv.${ch.reqLevel}</div>` : ''}
            </div>
        `;
    }).join('');

    // Daily button
    const dailyBtn = document.getElementById('dailyBtn');
    const mod = DailyChallenge.getModifiers();
    const completed = DailyChallenge.isCompleted();
    dailyBtn.innerHTML = completed ? '<img class="btn-icon" src="assets/icons/ui_calendar.png" alt=""> ë°ì¼ë¦¬ ì™„ë£Œ' : '<img class="btn-icon" src="assets/icons/ui_calendar.png" alt=""> '+mod.name;
    dailyBtn.style.opacity = completed ? 0.5 : 1;
}

function selectChar(idx) {
    if (!Progression.data.unlockedChars[idx]) return;
    Progression.data.selectedChar = idx;
    Progression.save();
    buildStartScreen();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ ASSET PRELOAD & INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function preloadAllAssets() {
    const lf = document.getElementById('loadFill');
    const lt = document.getElementById('loadText');
    const total = 17; let done = 0;
    const tick = () => { done++; if (lf) lf.style.width = Math.round((done/total)*100)+'%'; };
    if (lt) lt.textContent = 'Loading audio...';
    await AudioManager.preload((n,t) => { tick(); if (lt) lt.textContent = 'Audio '+n+'/'+t+'...'; });
    if (lt) lt.textContent = 'Loading sprites...';
    for (const nm of ['skill_1','skill_2','skill_3','skill_4','skill_5','skill_6','skill_7','skill_8']) {
        await new Promise(r => {
            const img = new Image();
            img.onload = () => { SKILL_SPRITES[nm] = img; tick(); r(); };
            img.onerror = () => { tick(); r(); };
            img.src = 'assets/sprites/'+nm+'.png';
        });
    }
    if (lt) lt.textContent = 'Ready!';
    if (lf) lf.style.width = '100%';
}

initSprites();
Progression.load();
buildStartScreen();

// UI click sounds on buttons
document.addEventListener('click', (e) => {
    if (e.target.closest('.btn,.char-card,.upgrade-card,#pauseBtn,#muteFab')) AudioManager._playBuf('click', 0.2);
});

preloadAllAssets().then(() => {
    setTimeout(() => {
        const ls = document.getElementById('loadingScreen');
        if (ls) { ls.classList.add('fade-out'); setTimeout(() => ls.remove(), 600); }
    }, 300);
}).catch(() => { const ls = document.getElementById('loadingScreen'); if (ls) ls.remove(); });

// Prevent zoom/scroll on mobile
document.addEventListener('touchmove', (e) => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
document.addEventListener('gesturestart', (e) => e.preventDefault());

// Resume audio on first interaction
document.addEventListener('click', () => AudioManager.resume(), { once: true });
document.addEventListener('touchstart', () => AudioManager.resume(), { once: true });

// Android ë’¤ë¡œê°€ê¸° â†’ ì¼ì‹œì •ì§€
history.pushState(null, '', '');
window.addEventListener('popstate', () => {
    if (game && game.running && !game.paused) {
        pauseGame();
    }
    history.pushState(null, '', '');
});
</script>

    <!-- Telegram Mini App Init -->
    <script>
    const T = GameI18n({
      start:{en:'Start Game',ko:'ê²Œì„ ì‹œì‘'}, retry:{en:'Retry',ko:'ë‹¤ì‹œ í•˜ê¸°'},
      lvUp:{en:'Level Up!',ko:'ë ˆë²¨ ì—…!'}
    });
    (function(){var s=function(){
      var ids={i18nStart:'start',i18nRetry:'retry',i18nLvUp:'lvUp'};
      for(var id in ids){var e=document.getElementById(id);if(e)e.textContent=T(ids[id]);}
    };if(document.readyState==='loading')document.addEventListener('DOMContentLoaded',s);else s();})();


    (function() {
        if (typeof TGBridge !== "undefined") {
            window.onTGBack = function() { return false; };
            console.log("[TG] Game ready:", document.title);
        }
    })();
    </script>
<script src="../cross-promo.js"></script>
<div class="attribution">Art: ê²Œì„ë§ˆë‹¹ (í•œêµ­ì½˜í…ì¸ ì§„í¥ì› Â· KOCCA)</div>
</body>
</html>
