<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
  <title>Stack Tower</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      width: 100%;
      max-width: 400px;
      height: 100vh;
      max-height: 700px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 10px;
      box-shadow: 0 0 40px rgba(0,150,255,0.3);
    }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #fff;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      pointer-events: none;
    }
    #combo {
      color: #ffd700;
      font-size: 18px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #combo.show { opacity: 1; }
    #menu, #gameover {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.8);
      color: #fff;
      border-radius: 10px;
    }
    #menu h1, #gameover h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(0,150,255,0.8);
    }
    #menu p, #gameover p {
      font-size: 18px;
      margin-bottom: 30px;
      color: #aaa;
    }
    .btn {
      padding: 15px 40px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      margin: 10px;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .btn:hover {
      transform: scale(1.05);
    }
    .btn-play {
      background: linear-gradient(135deg, #00d4ff, #0099ff);
      color: #fff;
      box-shadow: 0 5px 20px rgba(0,150,255,0.5);
    }
    .btn-retry {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: #fff;
      box-shadow: 0 5px 20px rgba(255,100,100,0.5);
    }
    #finalScore {
      font-size: 64px;
      color: #00d4ff;
      text-shadow: 0 0 30px rgba(0,150,255,0.8);
    }
    #bestScore {
      font-size: 20px;
      color: #ffd700;
      margin-top: 10px;
    }
    #newBest {
      color: #ff6b6b;
      font-size: 16px;
      animation: pulse 0.5s infinite alternate;
    }
    @keyframes pulse {
      from { opacity: 0.5; }
      to { opacity: 1; }
    }
    .hidden { display: none !important; }
    #perfectText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 36px;
      font-weight: bold;
      color: #ffd700;
      text-shadow: 0 0 20px rgba(255,215,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s, transform 0.3s;
    }
    #perfectText.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
    }
  </style>
    <!-- Telegram Mini App SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="/games/tg-sdk-wrapper.js?v=1769736738"></script>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game"></canvas>
    <div id="ui">
      <span id="score">0</span>
      <span id="combo"></span>
    </div>
    <div id="perfectText">PERFECT!</div>
    
    <div id="menu">
      <h1>üèóÔ∏è Stack Tower</h1>
      <p>Tap to drop & stack perfectly!</p>
      <button class="btn btn-play" onclick="startGame()">‚ñ∂ PLAY</button>
      <p style="margin-top:20px">Best: <span id="menuBest">0</span></p>
    </div>
    
    <div id="gameover" class="hidden">
      <h1>GAME OVER</h1>
      <div id="finalScore">0</div>
      <div id="bestScore">Best: 0</div>
      <div id="newBest" class="hidden">üéâ NEW RECORD!</div>
      <button class="btn btn-retry" onclick="startGame()">üîÑ RETRY</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // Responsive canvas
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game constants
    const BALANCE = {
      block: {
        initialWidth: 200,
        minWidth: 15,
        height: 25,
        perfectThreshold: 8,
      },
      speed: {
        initial: 4,
        increment: 0.15,
        max: 12,
      },
      scoring: {
        perfect: 100,
        good: 50,
        miss: 10,
      },
      perfectBonus: {
        growWidth: 8,
        comboRequired: 3,
      },
    };

    // Game state
    let gameState = 'menu';
    let score = 0;
    let combo = 0;
    let bestScore = parseInt(localStorage.getItem('stackTowerBest') || '0');
    let tower = [];
    let currentBlock = null;
    let fallingPieces = [];
    let cameraY = 0;
    let targetCameraY = 0;
    let speed = BALANCE.speed.initial;
    
    // Colors
    const colors = [
      '#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff', '#9b59b6',
      '#ff9f43', '#00d2d3', '#ff6b81', '#7bed9f', '#70a1ff'
    ];

    function getBlockColor(index) {
      return colors[index % colors.length];
    }

    function init() {
      document.getElementById('menuBest').textContent = bestScore;
      tower = [];
      fallingPieces = [];
      score = 0;
      combo = 0;
      cameraY = 0;
      targetCameraY = 0;
      speed = BALANCE.speed.initial;
      
      // Base block
      const baseWidth = BALANCE.block.initialWidth;
      tower.push({
        x: canvas.width / 2,
        y: canvas.height - 100,
        width: baseWidth,
        color: getBlockColor(0)
      });
      
      spawnBlock();
    }

    function spawnBlock() {
      const lastBlock = tower[tower.length - 1];
      currentBlock = {
        x: 0,
        y: lastBlock.y - BALANCE.block.height - 50,
        width: lastBlock.width,
        direction: 1,
        color: getBlockColor(tower.length)
      };
    }

    function dropBlock() {
      if (!currentBlock || gameState !== 'playing') return;
      
      const lastBlock = tower[tower.length - 1];
      const diff = currentBlock.x - lastBlock.x;
      const overlap = currentBlock.width / 2 + lastBlock.width / 2 - Math.abs(diff);
      
      if (overlap <= 0) {
        // Completely missed
        fallingPieces.push({
          x: currentBlock.x,
          y: currentBlock.y,
          width: currentBlock.width,
          color: currentBlock.color,
          vx: currentBlock.direction * 3,
          vy: 0
        });
        gameOver();
        return;
      }
      
      let newWidth, newX;
      let isPerfect = Math.abs(diff) <= BALANCE.block.perfectThreshold;
      
      if (isPerfect) {
        // Perfect placement
        combo++;
        newX = lastBlock.x;
        
        // Grow width on combo
        if (combo >= BALANCE.perfectBonus.comboRequired) {
          newWidth = Math.min(currentBlock.width + BALANCE.perfectBonus.growWidth, BALANCE.block.initialWidth);
        } else {
          newWidth = currentBlock.width;
        }
        
        score += BALANCE.scoring.perfect * combo;
        showPerfect();
      } else {
        combo = 0;
        newWidth = overlap;
        newX = diff > 0 
          ? lastBlock.x + (lastBlock.width / 2 - overlap / 2) + overlap / 2
          : lastBlock.x - (lastBlock.width / 2 - overlap / 2) - overlap / 2;
        
        // Create falling piece
        const sliceWidth = currentBlock.width - overlap;
        const sliceX = diff > 0
          ? currentBlock.x + overlap / 2 + sliceWidth / 2
          : currentBlock.x - overlap / 2 - sliceWidth / 2;
        
        fallingPieces.push({
          x: sliceX,
          y: currentBlock.y,
          width: sliceWidth,
          color: currentBlock.color,
          vx: diff > 0 ? 5 : -5,
          vy: 0
        });
        
        score += overlap > currentBlock.width * 0.7 ? BALANCE.scoring.good : BALANCE.scoring.miss;
      }
      
      // Check game over
      if (newWidth < BALANCE.block.minWidth) {
        gameOver();
        return;
      }
      
      // Add to tower
      tower.push({
        x: newX,
        y: lastBlock.y - BALANCE.block.height,
        width: newWidth,
        color: currentBlock.color
      });
      
      // Update camera
      if (tower.length > 5) {
        targetCameraY = (tower.length - 5) * BALANCE.block.height;
      }
      
      // Increase speed
      speed = Math.min(speed + BALANCE.speed.increment, BALANCE.speed.max);
      
      // Update UI
      updateUI();
      
      // Spawn next
      spawnBlock();
    }

    function showPerfect() {
      const text = document.getElementById('perfectText');
      text.textContent = combo >= 3 ? `PERFECT x${combo}!` : 'PERFECT!';
      text.classList.add('show');
      setTimeout(() => text.classList.remove('show'), 300);
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      const comboEl = document.getElementById('combo');
      if (combo >= 2) {
        comboEl.textContent = `x${combo}`;
        comboEl.classList.add('show');
      } else {
        comboEl.classList.remove('show');
      }
    }

    function gameOver() {
      gameState = 'gameover';
      
      const isNewBest = score > bestScore;
      if (isNewBest) {
        bestScore = score;
        localStorage.setItem('stackTowerBest', bestScore);
      }
      
      document.getElementById('finalScore').textContent = score;
      document.getElementById('bestScore').textContent = `Best: ${bestScore}`;
      document.getElementById('newBest').classList.toggle('hidden', !isNewBest);
      document.getElementById('gameover').classList.remove('hidden');
    }

    function startGame() {
      document.getElementById('menu').classList.add('hidden');
      document.getElementById('gameover').classList.add('hidden');
      gameState = 'playing';
      init();
      updateUI();
    }

    function update() {
      if (gameState !== 'playing' || !currentBlock) return;
      
      // Move current block
      currentBlock.x += speed * currentBlock.direction;
      
      // Bounce off walls
      const halfWidth = currentBlock.width / 2;
      if (currentBlock.x + halfWidth > canvas.width) {
        currentBlock.x = canvas.width - halfWidth;
        currentBlock.direction = -1;
      } else if (currentBlock.x - halfWidth < 0) {
        currentBlock.x = halfWidth;
        currentBlock.direction = 1;
      }
      
      // Smooth camera
      cameraY += (targetCameraY - cameraY) * 0.1;
      
      // Update falling pieces
      fallingPieces.forEach(p => {
        p.vy += 0.5;
        p.x += p.vx;
        p.y += p.vy;
      });
      fallingPieces = fallingPieces.filter(p => p.y < canvas.height + 100);
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#0f3460');
      gradient.addColorStop(1, '#1a1a2e');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.save();
      ctx.translate(0, cameraY);
      
      // Draw tower
      tower.forEach((block, i) => {
        drawBlock(block.x, block.y, block.width, BALANCE.block.height, block.color);
      });
      
      // Draw current block
      if (currentBlock && gameState === 'playing') {
        drawBlock(currentBlock.x, currentBlock.y, currentBlock.width, BALANCE.block.height, currentBlock.color);
        
        // Guide line
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(currentBlock.x, currentBlock.y + BALANCE.block.height);
        ctx.lineTo(currentBlock.x, tower[tower.length - 1].y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw falling pieces
      fallingPieces.forEach(p => {
        ctx.globalAlpha = 0.7;
        drawBlock(p.x, p.y, p.width, BALANCE.block.height, p.color);
        ctx.globalAlpha = 1;
      });
      
      ctx.restore();
    }

    function drawBlock(x, y, width, height, color) {
      const left = x - width / 2;
      
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(left + 5, y + 5, width, height);
      
      // Main block
      ctx.fillStyle = color;
      ctx.fillRect(left, y, width, height);
      
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(left, y, width, height * 0.3);
      
      // Border
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.lineWidth = 2;
      ctx.strokeRect(left, y, width, height);
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Input handling
    canvas.addEventListener('click', dropBlock);
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      dropBlock();
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'menu') startGame();
        else if (gameState === 'playing') dropBlock();
        else if (gameState === 'gameover') startGame();
      }
    });

    // Start
    init();
    gameLoop();
  </script>
</body>
</html>
