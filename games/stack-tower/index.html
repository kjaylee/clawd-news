<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ğŸ—ï¸ Stack Tower â€” ë¸”ë¡ ìŒ“ê¸°</title>
<meta property="og:title" content="ğŸ—ï¸ Stack Tower â€” ë¸”ë¡ ìŒ“ê¸°">
<meta property="og:type" content="website">
<meta property="og:url" content="https://eastsea.monster/games/stack-tower/">
<meta property="og:description" content="Play Stack Tower - ë¸”ë¡ì„ ìŒ“ì•„ ì˜¬ë ¤ë¼! Perfect/Good/Miss íŒì •, ì½¤ë³´ ì‹œìŠ¤í…œ. Free HTML5 game.">
<meta property="og:image" content="https://eastsea.monster/games/stack-tower/og-image.png">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0f0a1e;
  touch-action:none;-webkit-tap-highlight-color:transparent;user-select:none;
  font-family:'Segoe UI',-apple-system,BlinkMacSystemFont,'Helvetica Neue',sans-serif}
canvas{display:block;width:100%;height:100%}
</style>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="/games/tg-sdk-wrapper.js?v=1769736738"></script>
</head>
<body>
<canvas id="gc"></canvas>
<script>
'use strict';
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//   STACK TOWER  â€”  HTML5 Canvas, single-file, no deps
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const cvs = document.getElementById('gc');
const ctx = cvs.getContext('2d');

/* â”€â”€ responsive sizing â”€â”€ */
let W, H, dpr;
function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = window.innerWidth;
  H = window.innerHeight;
  cvs.width  = W * dpr;
  cvs.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

/* â”€â”€ balance constants (from spec) â”€â”€ */
const B = {
  initW: 200, minW: 20, blockH: 30,
  perfectPx: 5, goodPx: 15,
  spdInit: 3, spdInc: 0.1, spdMax: 8,
  ptsPerfect: 100, ptsGood: 50, ptsMiss: 10,
  growW: 5, growCombo: 3,
  dropSpd: 15, camLerp: 0.08, sliceSpd: 5,
  depth3D: 8                       // pseudo-3D extrusion
};

/* â”€â”€ palette: pastel hue walk â”€â”€ */
function hue(i){ return (i * 19 + 210) % 360; }
function colFront(i){ return `hsl(${hue(i)},60%,72%)`; }
function colDark(i) { return `hsl(${hue(i)},50%,52%)`; }
function colLight(i){ return `hsl(${hue(i)},70%,85%)`; }

/* â”€â”€ state machine â”€â”€ */
const S = { MENU:0, PLAY:1, OVER:2 };
let st = S.MENU;

/* â”€â”€ game vars â”€â”€ */
let score, combo, maxCombo, tower, cur, slices, sparks, texts;
let camY, camTarget, isNew, shakeAmt, tick;
let hi = +localStorage.getItem('stHi') || 0;

/* â”€â”€ btn rects (set during draw) â”€â”€ */
let btnPlay = null, btnRetry = null, btnHome = null;

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• init / spawn â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function initGame() {
  score = 0; combo = 0; maxCombo = 0; tick = 0; isNew = false;
  tower = []; slices = []; sparks = []; texts = [];
  camY = 0; camTarget = 0; shakeAmt = 0;

  // base block
  const bw = B.initW;
  tower.push({ x: W/2 - bw/2, y: H - 70 - B.blockH, w: bw });
  spawn();
  st = S.PLAY;
}

function spawn() {
  const prev = tower[tower.length - 1];
  const w = prev.w;
  const y = prev.y - B.blockH;
  const fromRight = tower.length % 2 === 0;
  cur = {
    x: fromRight ? W + 20 : -w - 20,
    y, w,
    dir: fromRight ? -1 : 1,
    spd: Math.min(B.spdInit + (tower.length - 1) * B.spdInc, B.spdMax)
  };
  camTarget = Math.max(0, (tower.length - 7) * B.blockH);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• drop / judge â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function drop() {
  if (st !== S.PLAY || !cur) return;
  const prev = tower[tower.length - 1];
  const c = cur;
  const off = c.x - prev.x;
  const abs = Math.abs(off);

  // overlap range
  const oS = Math.max(c.x, prev.x);
  const oE = Math.min(c.x + c.w, prev.x + prev.w);
  const oW = oE - oS;

  /* â€” PERFECT â€” */
  if (abs <= B.perfectPx) {
    const nb = { x: prev.x, y: c.y, w: prev.w };
    tower.push(nb);
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    score += B.ptsPerfect * Math.max(1, Math.floor(combo / 2));

    // grow every N perfects
    if (combo >= B.growCombo && combo % B.growCombo === 0) {
      nb.w = Math.min(nb.w + B.growW, B.initW);
      nb.x -= B.growW / 2;
      if (nb.x < 0) nb.x = 0;
      if (nb.x + nb.w > W) nb.x = W - nb.w;
      emitText('WIDTH +5!', c.y + 30, '#00E676', 15);
    }
    emitText('âœ¦ PERFECT! âœ¦', c.y, '#FFD700', combo >= 3 ? 28 : 22);
    if (combo >= 3) emitText(`ğŸ”¥ x${combo} COMBO`, c.y + 26, '#FF6B35', 17);
    emitSparks(prev.x + prev.w / 2, c.y, 22);
    shakeAmt = 5;
    spawn();
    return;
  }

  /* â€” no overlap at all â†’ FAIL â€” */
  if (oW <= 0) {
    addSlice(c.x, c.y, c.w, c.dir);
    gameOver();
    return;
  }

  /* â€” overlap too small â†’ game over â€” */
  if (oW < B.minW) {
    addSlice(c.x, c.y, c.w, off > 0 ? 1 : -1);
    gameOver();
    return;
  }

  /* â€” GOOD or MISS (has overlap, trimmed) â€” */
  const isGood = abs <= B.goodPx;
  tower.push({ x: oS, y: c.y, w: oW });

  // flying slice
  if (off > 0) {
    const sw = c.x + c.w - oE;
    if (sw > 1) addSlice(oE, c.y, sw, 1);
  } else {
    const sw = oS - c.x;
    if (sw > 1) addSlice(c.x, c.y, sw, -1);
  }
  score += isGood ? B.ptsGood : B.ptsMiss;
  emitText(isGood ? 'GOOD' : 'MISS', c.y,
           isGood ? '#74b9ff' : '#b2bec3', 18);
  combo = 0;
  spawn();
}

function gameOver() {
  st = S.OVER; combo = 0;
  if (score > hi) { hi = score; localStorage.setItem('stHi', hi); isNew = true; }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• effects â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function addSlice(x, y, w, dir) {
  slices.push({ x, y, w, h: B.blockH,
    vx: dir * (3 + Math.random() * 4), vy: -2 - Math.random() * 3,
    rot: 0, vr: dir * (0.04 + Math.random() * 0.08),
    a: 1, col: colFront(tower.length), colD: colDark(tower.length) });
}
function emitSparks(cx, cy, n) {
  for (let i = 0; i < n; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = 2 + Math.random() * 5;
    sparks.push({ x: cx, y: cy, vx: Math.cos(a)*s, vy: Math.sin(a)*s - 2,
      life: 1, dec: 0.014 + Math.random() * 0.02,
      r: 2 + Math.random() * 3,
      col: ['#FFD700','#FF6B35','#FFF','#FFEAA7','#FD79A8'][Math.random()*5|0] });
  }
}
function emitText(t, y, col, sz) {
  texts.push({ t, x: W/2, y, a: 1, vy: -1.2, col, sz, life: 70 });
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• update â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function update() {
  tick++;
  camY += (camTarget - camY) * B.camLerp;
  if (shakeAmt > 0.3) shakeAmt *= 0.82; else shakeAmt = 0;

  // current block
  if (st === S.PLAY && cur) {
    cur.x += cur.dir * cur.spd;
    if (cur.x + cur.w > W + 60) cur.dir = -1;
    if (cur.x < -60) cur.dir = 1;
  }

  // slices
  for (let i = slices.length - 1; i >= 0; i--) {
    const s = slices[i];
    s.x += s.vx; s.y += s.vy; s.vy += 0.35;
    s.rot += s.vr; s.a -= 0.01;
    if (s.a <= 0) slices.splice(i, 1);
  }
  // sparks
  for (let i = sparks.length - 1; i >= 0; i--) {
    const p = sparks[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.12;
    p.life -= p.dec;
    if (p.life <= 0) sparks.splice(i, 1);
  }
  // texts
  for (let i = texts.length - 1; i >= 0; i--) {
    const f = texts[i];
    f.y += f.vy; f.life--;
    if (f.life < 18) f.a -= 0.055;
    if (f.a <= 0 || f.life <= 0) texts.splice(i, 1);
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• draw helpers â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function drawBg() {
  const t = tick * 0.15;
  const h1 = (t * 0.25) % 360;
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, `hsl(${h1},22%,10%)`);
  g.addColorStop(0.5, `hsl(${(h1+25)%360},28%,15%)`);
  g.addColorStop(1, `hsl(${(h1+50)%360},18%,18%)`);
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // stars
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 45; i++) {
    const sx = ((42 * (i+1) * 7919) % 10000) / 10000 * W;
    const sy = ((42 * (i+1) * 6271) % 10000) / 10000 * H;
    const sr = ((42 * (i+1) * 3571) % 10000) / 10000 * 1.4 + 0.4;
    ctx.globalAlpha = (Math.sin(tick * 0.04 + i * 1.7) * 0.25 + 0.35) * 0.45;
    ctx.beginPath(); ctx.arc(sx, sy, sr, 0, 6.283); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function block3D(x, y, w, h, cf, cd, cl, alpha) {
  const d = B.depth3D;
  const prev = ctx.globalAlpha;
  if (alpha !== undefined) ctx.globalAlpha = alpha;

  // top face
  ctx.fillStyle = cl || cf;
  ctx.beginPath();
  ctx.moveTo(x, y); ctx.lineTo(x + d, y - d);
  ctx.lineTo(x + w + d, y - d); ctx.lineTo(x + w, y);
  ctx.closePath(); ctx.fill();

  // right face
  ctx.fillStyle = cd || cf;
  ctx.beginPath();
  ctx.moveTo(x + w, y); ctx.lineTo(x + w + d, y - d);
  ctx.lineTo(x + w + d, y + h - d); ctx.lineTo(x + w, y + h);
  ctx.closePath(); ctx.fill();

  // front face
  ctx.fillStyle = cf;
  ctx.fillRect(x, y, w, h);

  // gloss line
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.lineWidth = 0.5;
  ctx.strokeRect(x + 0.5, y + 0.5, w - 1, h - 1);

  ctx.globalAlpha = prev;
}

function drawTower() {
  const sx = shakeAmt > 0 ? (Math.random() - 0.5) * shakeAmt * 2 : 0;
  const sy = shakeAmt > 0 ? (Math.random() - 0.5) * shakeAmt * 2 : 0;
  ctx.save();
  ctx.translate(sx, camY + sy);

  // tower blocks
  for (let i = 0; i < tower.length; i++) {
    const b = tower[i];
    block3D(b.x, b.y, b.w, B.blockH, colFront(i), colDark(i), colLight(i));
  }

  // current moving block
  if (cur && st === S.PLAY) {
    const i = tower.length;
    block3D(cur.x, cur.y, cur.w, B.blockH, colFront(i), colDark(i), colLight(i));
    // guide outline
    const prev = tower[tower.length - 1];
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    ctx.strokeRect(prev.x, cur.y, prev.w, B.blockH);
    ctx.setLineDash([]);
  }

  // slices
  for (const s of slices) {
    ctx.save();
    ctx.globalAlpha = s.a;
    ctx.translate(s.x + s.w / 2, s.y + s.h / 2);
    ctx.rotate(s.rot);
    block3D(-s.w / 2, -s.h / 2, s.w, s.h, s.col, s.colD);
    ctx.restore();
  }

  // sparks
  for (const p of sparks) {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r * p.life, 0, 6.283);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // floating texts (world-space â†’ apply camera)
  for (const f of texts) {
    ctx.globalAlpha = Math.max(0, f.a);
    ctx.fillStyle = f.col;
    ctx.font = `bold ${f.sz}px 'Segoe UI',sans-serif`;
    ctx.textAlign = 'center';
    ctx.shadowColor = f.col; ctx.shadowBlur = 12;
    ctx.fillText(f.t, f.x, f.y);
    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

/* â”€â”€ HUD (play screen) â”€â”€ */
function drawHUD() {
  ctx.textAlign = 'left';
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 26px "Segoe UI",sans-serif';
  ctx.fillText(score.toLocaleString(), 20, 46);

  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.font = '13px "Segoe UI",sans-serif';
  ctx.fillText(`${tower.length - 1}ì¸µ Floor`, 20, 66);

  if (combo >= 2 && st === S.PLAY) {
    ctx.textAlign = 'right';
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 20px "Segoe UI",sans-serif';
    ctx.fillText(`ğŸ”¥ x${combo}`, W - 18, 46);
  }
}

/* â”€â”€ rounded rect (path only) â”€â”€ */
function rr(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MENU â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function drawMenu() {
  drawBg();

  ctx.textAlign = 'center';

  // glow
  const gl = ctx.createRadialGradient(W/2, H*0.26, 0, W/2, H*0.26, 180);
  gl.addColorStop(0, 'rgba(255,215,0,0.07)');
  gl.addColorStop(1, 'rgba(255,215,0,0)');
  ctx.fillStyle = gl; ctx.fillRect(0, 0, W, H);

  // animated mini-tower
  const bx = W / 2 - 55;
  const by = H * 0.15;
  for (let i = 0; i < 6; i++) {
    const sway = Math.sin(tick * 0.025 + i * 0.6) * (3 + i * 0.5);
    const bw = 110 - i * 6;
    block3D(bx + sway + (110 - bw) / 2, by + i * 22, bw, 20,
      colFront(i + 4), colDark(i + 4), colLight(i + 4));
  }

  // title
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 44px "Segoe UI",sans-serif';
  ctx.fillText('STACK TOWER', W / 2, H * 0.40);

  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = '15px "Segoe UI",sans-serif';
  ctx.fillText('ë¸”ë¡ ìŒ“ê¸°', W / 2, H * 0.45);

  // high score
  if (hi > 0) {
    ctx.fillStyle = '#FFD700';
    ctx.font = '17px "Segoe UI",sans-serif';
    ctx.fillText(`â˜… Best: ${hi.toLocaleString()}`, W / 2, H * 0.52);
  }

  // play button
  const bw2 = 190, bh2 = 56;
  const bx2 = W / 2 - bw2 / 2;
  const by2 = H * 0.59;
  const pulse = Math.sin(tick * 0.06) * 3;

  ctx.shadowColor = '#FFD700'; ctx.shadowBlur = 16 + pulse;
  const bg = ctx.createLinearGradient(bx2, by2, bx2, by2 + bh2);
  bg.addColorStop(0, '#FFD700'); bg.addColorStop(1, '#FFA502');
  ctx.fillStyle = bg;
  rr(bx2, by2, bw2, bh2, 28); ctx.fill();
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#1a1a2e';
  ctx.font = 'bold 22px "Segoe UI",sans-serif';
  ctx.fillText('â–¶  PLAY', W / 2, by2 + bh2 / 2 + 8);

  // instructions
  ctx.fillStyle = 'rgba(255,255,255,0.28)';
  ctx.font = '13px "Segoe UI",sans-serif';
  ctx.fillText('Tap or press Space to drop!', W / 2, H * 0.77);
  ctx.fillText('í„°ì¹˜ ë˜ëŠ” ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ë¸”ë¡ì„ ë–¨ì–´ëœ¨ë¦¬ì„¸ìš”', W / 2, H * 0.81);

  btnPlay = { x: bx2, y: by2, w: bw2, h: bh2 };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME OVER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function drawOver() {
  // dim
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center';

  // title
  ctx.fillStyle = '#FF6B6B';
  ctx.font = 'bold 38px "Segoe UI",sans-serif';
  ctx.fillText('GAME OVER', W / 2, H * 0.22);

  // score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 54px "Segoe UI",sans-serif';
  ctx.fillText(score.toLocaleString(), W / 2, H * 0.33);

  // floors
  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = '14px "Segoe UI",sans-serif';
  ctx.fillText(`${tower.length - 1}ì¸µ ë„ë‹¬  Â·  ${tower.length - 1} floors`, W / 2, H * 0.38);

  // max combo
  if (maxCombo >= 2) {
    ctx.fillStyle = '#FFD700';
    ctx.font = '15px "Segoe UI",sans-serif';
    ctx.fillText(`Max Combo: x${maxCombo}`, W / 2, H * 0.43);
  }

  // high score
  const hy = H * 0.50;
  ctx.fillStyle = isNew ? '#FFD700' : 'rgba(255,255,255,0.55)';
  ctx.font = `${isNew ? 'bold ' : ''}18px "Segoe UI",sans-serif`;
  const ht = `â˜… Best: ${hi.toLocaleString()}`;
  ctx.fillText(ht, W / 2, hy);

  if (isNew) {
    const pw = Math.sin(tick * 0.08) * 0.18 + 0.82;
    ctx.globalAlpha = pw;
    ctx.fillStyle = '#FF6B35';
    ctx.font = 'bold 14px "Segoe UI",sans-serif';
    ctx.fillText('NEW!', W / 2 + ctx.measureText(ht).width / 2 + 28, hy);
    ctx.globalAlpha = 1;
  }

  // retry button
  const bw = 170, bh = 52;
  const rx = W / 2 - bw / 2;
  const ry = H * 0.58;

  const rg = ctx.createLinearGradient(rx, ry, rx, ry + bh);
  rg.addColorStop(0, '#6C5CE7'); rg.addColorStop(1, '#5541D5');
  ctx.fillStyle = rg;
  ctx.shadowColor = '#6C5CE7'; ctx.shadowBlur = 10;
  rr(rx, ry, bw, bh, 26); ctx.fill();
  ctx.shadowBlur = 0;

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 18px "Segoe UI",sans-serif';
  ctx.fillText('ğŸ”„ Retry', W / 2, ry + bh / 2 + 7);

  // home button
  const hby = ry + bh + 16;
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  rr(rx, hby, bw, bh, 26); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 1;
  rr(rx, hby, bw, bh, 26); ctx.stroke();

  ctx.fillStyle = '#fff';
  ctx.font = '16px "Segoe UI",sans-serif';
  ctx.fillText('ğŸ  Home', W / 2, hby + bh / 2 + 6);

  btnRetry = { x: rx, y: ry, w: bw, h: bh };
  btnHome  = { x: rx, y: hby, w: bw, h: bh };
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• main loop â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function frame() {
  ctx.clearRect(0, 0, W, H);
  if (st === S.MENU) {
    tick++;
    drawMenu();
  } else {
    update();
    drawBg();
    drawTower();
    drawHUD();
    if (st === S.OVER) drawOver();
  }
  requestAnimationFrame(frame);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• input â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

function hit(px, py, r) {
  return r && px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

function tap(px, py) {
  if (st === S.MENU) { if (hit(px, py, btnPlay)) initGame(); return; }
  if (st === S.PLAY) { drop(); return; }
  if (st === S.OVER) {
    if (hit(px, py, btnRetry)) { initGame(); return; }
    if (hit(px, py, btnHome))  { st = S.MENU; return; }
  }
}

cvs.addEventListener('touchstart', e => {
  e.preventDefault();
  const t = e.touches[0]; tap(t.clientX, t.clientY);
}, { passive: false });

cvs.addEventListener('mousedown', e => tap(e.clientX, e.clientY));

window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'Enter') {
    e.preventDefault();
    if (st === S.MENU) initGame();
    else if (st === S.PLAY) drop();
    else if (st === S.OVER) initGame();
  }
  if (e.code === 'Escape' && st === S.OVER) st = S.MENU;
});

/* â”€â”€ start â”€â”€ */
frame();
</script>
<script src="../cross-promo.js"></script>
</body>
</html>
