<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Puzzle Rogue Dungeon</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{
--bg:#0a0a12;--bg2:#12121f;--bg3:#1a1a2e;--panel:#16213e;
--gold:#f0c040;--red:#e74c3c;--blue:#3498db;--green:#2ecc71;
--yellow:#f1c40f;--purple:#9b59b6;--gray:#555;--white:#eee;
--hp-red:#c0392b;--hp-bg:#2c1a1a;--mana-blue:#2980b9;
--ult-purple:#8e44ad;--shield-blue:#2471a3;
}
html,body{width:100%;height:100%;overflow:hidden;background:var(--bg);color:var(--white);font-family:'Segoe UI',system-ui,sans-serif}
#app{width:100%;height:100%;display:flex;flex-direction:column;max-width:480px;margin:0 auto;position:relative;overflow:hidden}

/* Screens */
.screen{display:none;flex-direction:column;width:100%;height:100%;position:absolute;top:0;left:0;z-index:1}
.screen.active{display:flex;z-index:10}

/* Title Screen */
#title-screen{justify-content:center;align-items:center;background:radial-gradient(ellipse at center,#1a1a3e 0%,#0a0a12 70%);text-align:center}
#title-screen h1{font-size:2em;color:var(--gold);text-shadow:0 0 20px rgba(240,192,64,.5);margin-bottom:.2em;letter-spacing:2px}
#title-screen h2{font-size:1em;color:#888;margin-bottom:2em}
.menu-btn{display:block;width:80%;max-width:300px;margin:.4em auto;padding:.8em;border:2px solid var(--gold);background:rgba(240,192,64,.1);color:var(--gold);font-size:1.1em;border-radius:8px;cursor:pointer;transition:all .2s}
.menu-btn:hover,.menu-btn:active{background:rgba(240,192,64,.25);transform:scale(1.02)}
.menu-btn:disabled{opacity:.4;cursor:default;transform:none}
.stats-line{color:#777;font-size:.85em;margin-top:1.5em;line-height:1.8}

/* Hero Select */
#hero-screen{padding:1em;background:var(--bg)}
#hero-screen h2{text-align:center;color:var(--gold);margin-bottom:.8em}
.hero-grid{display:grid;grid-template-columns:1fr 1fr;gap:.8em;flex:1;overflow-y:auto}
.hero-card{border:2px solid #333;border-radius:12px;padding:1em;text-align:center;cursor:pointer;background:var(--bg2);transition:all .2s}
.hero-card.selected{border-color:var(--gold);background:rgba(240,192,64,.1);box-shadow:0 0 15px rgba(240,192,64,.3)}
.hero-card.locked{opacity:.5;cursor:default}
.hero-icon{font-size:2.5em;margin-bottom:.3em}
.hero-name{font-size:1.1em;font-weight:bold;color:var(--gold)}
.hero-stats{font-size:.8em;color:#aaa;margin-top:.5em;line-height:1.6}
#start-run{margin-top:auto;padding:1em;font-size:1.2em;background:var(--gold);color:#111;border:none;border-radius:10px;cursor:pointer;font-weight:bold}
#start-run:disabled{opacity:.4}

/* Battle Screen */
#battle-screen{background:var(--bg)}
.enemy-panel{padding:.6em 1em;background:var(--bg2);border-bottom:1px solid #222}
.enemy-top{display:flex;justify-content:space-between;align-items:center}
.floor-info{color:var(--gold);font-size:.85em;font-weight:bold}
.enemy-name{font-size:1.1em;font-weight:bold}
.enemy-hp-bar{height:14px;background:var(--hp-bg);border-radius:7px;margin:.4em 0;overflow:hidden;position:relative}
.enemy-hp-fill{height:100%;background:linear-gradient(90deg,var(--hp-red),#e74c3c);border-radius:7px;transition:width .4s}
.enemy-hp-text{position:absolute;right:6px;top:50%;transform:translateY(-50%);font-size:.7em;color:#fff;text-shadow:1px 1px 2px #000}
.enemy-intent{font-size:.85em;color:#ccc;padding:.2em 0}
.enemy-intent span{color:var(--red)}
.enemy-sprite{text-align:center;font-size:3em;padding:.3em 0;text-shadow:0 0 20px rgba(255,0,0,.3)}
.boss-label{text-align:center;color:var(--gold);font-size:.75em;font-weight:bold;letter-spacing:2px}
.enemy-debuffs{display:flex;gap:4px;flex-wrap:wrap;padding:2px 0}
.debuff-icon{font-size:.75em;background:rgba(255,255,255,.1);border-radius:4px;padding:1px 4px}

/* Grid */
.grid-container{flex:1;display:flex;justify-content:center;align-items:center;padding:.5em;position:relative;touch-action:none}
.grid{display:grid;grid-template-columns:repeat(6,1fr);grid-template-rows:repeat(6,1fr);gap:4px;width:100%;max-width:360px;aspect-ratio:1}
.gem{border-radius:10px;display:flex;justify-content:center;align-items:center;font-size:1.8em;cursor:pointer;transition:transform .15s,opacity .2s;position:relative;user-select:none;-webkit-user-select:none}
.gem.selected{transform:scale(1.15);box-shadow:0 0 12px rgba(255,255,255,.5);z-index:2}
.gem.matched{animation:gemPop .3s ease-out forwards}
.gem.dropping{animation:gemDrop .3s ease-out}
.gem.new-gem{animation:gemAppear .3s ease-out}
.gem-red{background:linear-gradient(135deg,#c0392b,#e74c3c)}
.gem-blue{background:linear-gradient(135deg,#2471a3,#3498db)}
.gem-green{background:linear-gradient(135deg,#27ae60,#2ecc71)}
.gem-yellow{background:linear-gradient(135deg,#d4a017,#f1c40f)}
.gem-purple{background:linear-gradient(135deg,#7d3c98,#9b59b6)}
.gem-star{background:linear-gradient(135deg,#c8a415,#f5e642);animation:starPulse 2s infinite}
.gem-curse{background:linear-gradient(135deg,#1a1a1a,#333);border:1px solid #555}

@keyframes gemPop{0%{transform:scale(1);opacity:1}50%{transform:scale(1.3);opacity:.8}100%{transform:scale(0);opacity:0}}
@keyframes gemDrop{0%{transform:translateY(-60px);opacity:.5}100%{transform:translateY(0);opacity:1}}
@keyframes gemAppear{0%{transform:scale(0);opacity:0}100%{transform:scale(1);opacity:1}}
@keyframes starPulse{0%,100%{box-shadow:0 0 5px rgba(245,230,66,.5)}50%{box-shadow:0 0 15px rgba(245,230,66,.8)}}

/* Player Panel */
.player-panel{padding:.5em .8em;background:var(--bg2);border-top:1px solid #222}
.bars-row{display:flex;gap:.5em;margin-bottom:.4em}
.bar-wrap{flex:1}
.bar-label{font-size:.65em;color:#999;display:flex;justify-content:space-between}
.bar{height:10px;border-radius:5px;overflow:hidden;background:var(--hp-bg)}
.bar-hp .bar-fill{background:linear-gradient(90deg,#c0392b,#27ae60);transition:width .4s}
.bar-shield .bar-fill{background:var(--shield-blue);transition:width .4s}
.bar-mana .bar-fill{background:var(--mana-blue);transition:width .4s}
.bar-ult .bar-fill{background:linear-gradient(90deg,var(--ult-purple),#c39bd3);transition:width .4s}
.action-row{display:flex;gap:.5em}
.action-btn{flex:1;padding:.6em;border:2px solid;border-radius:8px;font-size:.85em;font-weight:bold;cursor:pointer;background:transparent;transition:all .2s}
.action-btn:disabled{opacity:.3;cursor:default}
.btn-skill{border-color:var(--mana-blue);color:var(--mana-blue)}
.btn-skill:not(:disabled):active{background:rgba(52,152,219,.2)}
.btn-ult{border-color:var(--ult-purple);color:var(--ult-purple)}
.btn-ult:not(:disabled):active{background:rgba(155,89,182,.2)}
.btn-potion{border-color:var(--green);color:var(--green)}
.btn-potion:not(:disabled):active{background:rgba(46,204,113,.2)}

/* Relics & Gold row */
.info-row{display:flex;justify-content:space-between;align-items:center;font-size:.75em;color:#aaa;padding:.3em 0}
.relics-display{display:flex;gap:3px}
.relic-icon{font-size:1.1em}

/* Reward Screen */
#reward-screen{justify-content:center;align-items:center;background:rgba(0,0,0,.9);padding:1.5em}
#reward-screen h2{color:var(--gold);text-align:center;margin-bottom:.3em;font-size:1.5em}
#reward-screen .sub{color:#aaa;text-align:center;margin-bottom:1.5em;font-size:.9em}
.reward-cards{display:flex;gap:.8em;justify-content:center;margin-bottom:1.5em}
.reward-card{width:110px;padding:1em .5em;border:2px solid #444;border-radius:12px;text-align:center;cursor:pointer;background:var(--bg2);transition:all .2s}
.reward-card:hover,.reward-card:active{border-color:var(--gold);transform:translateY(-5px)}
.reward-card .r-icon{font-size:2em;margin-bottom:.3em}
.reward-card .r-name{font-size:.85em;font-weight:bold;color:var(--gold)}
.reward-card .r-desc{font-size:.7em;color:#aaa;margin-top:.3em;line-height:1.3}
.skip-btn{display:block;margin:0 auto;padding:.6em 2em;background:none;border:1px solid #555;color:#777;border-radius:6px;cursor:pointer;font-size:.85em}

/* Event/Rest/Shop screen */
#event-screen{justify-content:center;align-items:center;background:rgba(0,0,0,.92);padding:1.5em}
#event-screen h2{color:var(--gold);margin-bottom:.5em;font-size:1.3em}
.event-choices{width:100%;max-width:320px}
.event-btn{display:block;width:100%;padding:1em;margin:.5em 0;border:2px solid #444;background:var(--bg2);color:var(--white);border-radius:10px;font-size:1em;cursor:pointer;text-align:left;transition:all .2s}
.event-btn:active{border-color:var(--gold);background:rgba(240,192,64,.1)}
.event-btn .ev-icon{font-size:1.3em;margin-right:.5em}

/* Game Over */
#gameover-screen{justify-content:center;align-items:center;background:rgba(0,0,0,.95);text-align:center;padding:2em}
#gameover-screen h2{font-size:2em;margin-bottom:.3em}
#gameover-screen .go-sub{color:#aaa;margin-bottom:1.5em}
.go-stats{margin:1em 0;line-height:2;color:#ccc}
.go-stats span{color:var(--gold);font-weight:bold}
#go-sp{font-size:1.5em;color:var(--gold);margin:1em 0}

/* Upgrades */
#upgrade-screen{padding:1em;background:var(--bg);overflow-y:auto}
#upgrade-screen h2{text-align:center;color:var(--gold);margin-bottom:.5em}
.sp-display{text-align:center;font-size:1.2em;color:var(--gold);margin-bottom:1em}
.upgrade-list{flex:1;overflow-y:auto}
.upgrade-item{display:flex;justify-content:space-between;align-items:center;padding:.8em;margin:.4em 0;background:var(--bg2);border-radius:8px;border:1px solid #333}
.upgrade-item .u-info{flex:1}
.upgrade-item .u-name{font-weight:bold;font-size:.95em}
.upgrade-item .u-desc{font-size:.75em;color:#aaa;margin-top:.2em}
.upgrade-item .u-level{font-size:.7em;color:var(--gold)}
.u-buy{padding:.5em 1em;border:2px solid var(--gold);background:rgba(240,192,64,.1);color:var(--gold);border-radius:6px;cursor:pointer;font-weight:bold;font-size:.85em}
.u-buy:disabled{opacity:.3;cursor:default}
.back-btn{display:block;margin:1em auto;padding:.7em 2em;border:1px solid #555;background:none;color:#aaa;border-radius:6px;cursor:pointer;font-size:.9em}

/* Codex */
#codex-screen{padding:1em;background:var(--bg);overflow-y:auto}
#codex-screen h2{text-align:center;color:var(--gold);margin-bottom:.8em}
.codex-section{margin-bottom:1.5em}
.codex-section h3{color:var(--gold);font-size:.9em;margin-bottom:.5em;border-bottom:1px solid #333;padding-bottom:.3em}
.codex-grid{display:flex;flex-wrap:wrap;gap:.5em}
.codex-entry{width:60px;height:60px;display:flex;flex-direction:column;justify-content:center;align-items:center;background:var(--bg2);border-radius:8px;font-size:.7em;text-align:center;border:1px solid #333}
.codex-entry.undiscovered{opacity:.3}
.codex-entry .ce-icon{font-size:1.5em}

/* Floating damage */
.float-text{position:absolute;font-weight:bold;font-size:1.2em;pointer-events:none;z-index:100;animation:floatUp 1s ease-out forwards;text-shadow:1px 1px 3px #000}
@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-40px)}}

/* Shake */
.shake{animation:shake .3s}
@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-5px)}75%{transform:translateX(5px)}}

/* Chain indicator */
.chain-popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:2em;font-weight:bold;color:var(--gold);text-shadow:0 0 20px rgba(240,192,64,.8);pointer-events:none;z-index:50;animation:chainPop .8s ease-out forwards}
@keyframes chainPop{0%{opacity:0;transform:translate(-50%,-50%) scale(0.5)}30%{opacity:1;transform:translate(-50%,-50%) scale(1.3)}100%{opacity:0;transform:translate(-50%,-50%) scale(1) translateY(-30px)}}

/* Victory */
#victory-screen{justify-content:center;align-items:center;background:rgba(0,0,0,.95);text-align:center;padding:2em}
#victory-screen h2{font-size:2em;color:var(--gold);text-shadow:0 0 30px rgba(240,192,64,.5)}

/* Scrollbar */
::-webkit-scrollbar{width:4px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:#333;border-radius:2px}

/* Mute FAB */
.mute-fab{position:fixed;top:10px;right:10px;width:44px;height:44px;border-radius:50%;background:rgba(30,30,50,.85);border:2px solid rgba(240,192,64,.3);color:var(--gold);font-size:1.3em;cursor:pointer;z-index:999;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);transition:all .2s}
.mute-fab:active{transform:scale(.9);background:rgba(240,192,64,.2)}
</style>
</head>
<body>
<div id="app">

<!-- Title -->
<div id="title-screen" class="screen active">
  <h1>‚öîÔ∏è PUZZLE ROGUE<br>DUNGEON</h1>
  <h2>ÌçºÏ¶ê Î°úÍ∑∏ ÎçòÏ†Ñ</h2>
  <button class="menu-btn" onclick="showScreen('hero-screen')">üè∞ NEW RUN</button>
  <button class="menu-btn" onclick="showScreen('upgrade-screen')">‚¨ÜÔ∏è UPGRADES</button>
  <button class="menu-btn" onclick="showScreen('codex-screen')">üìä CODEX</button>
  <div class="stats-line">
    <div>üíÄ Best: Floor <span id="s-best">0</span></div>
    <div>üèÉ Total Runs: <span id="s-runs">0</span></div>
    <div>‚ú® Soul Points: <span id="s-sp">0</span></div>
  </div>
</div>

<!-- Hero Select -->
<div id="hero-screen" class="screen">
  <h2>‚öîÔ∏è SELECT HERO</h2>
  <div class="hero-grid" id="hero-grid"></div>
  <button id="start-run" onclick="startRun()" disabled>START RUN</button>
  <button class="back-btn" onclick="showScreen('title-screen')">‚Üê Back</button>
</div>

<!-- Battle -->
<div id="battle-screen" class="screen">
  <div class="enemy-panel">
    <div class="enemy-top">
      <span class="floor-info" id="b-floor">F1/25</span>
      <span class="enemy-name" id="b-ename">Slime</span>
    </div>
    <div class="enemy-hp-bar">
      <div class="enemy-hp-fill" id="b-ehp-fill"></div>
      <div class="enemy-hp-text" id="b-ehp-text">100/100</div>
    </div>
    <div class="enemy-debuffs" id="b-edebuffs"></div>
    <div class="enemy-intent" id="b-intent">Next: ‚öîÔ∏è Attack <span>10 dmg</span></div>
    <div class="boss-label" id="b-boss-label" style="display:none">‚òÖ BOSS ‚òÖ</div>
    <div class="enemy-sprite" id="b-esprite">üü¢</div>
  </div>

  <div class="grid-container" id="grid-container">
    <div class="grid" id="grid"></div>
  </div>

  <div class="player-panel">
    <div class="bars-row">
      <div class="bar-wrap"><div class="bar-label"><span>‚ù§Ô∏è HP</span><span id="b-hp-text">100/100</span></div><div class="bar bar-hp"><div class="bar-fill" id="b-hp-fill"></div></div></div>
      <div class="bar-wrap"><div class="bar-label"><span>üõ°Ô∏è</span><span id="b-shield-text">0</span></div><div class="bar bar-shield"><div class="bar-fill" id="b-shield-fill" style="width:0"></div></div></div>
    </div>
    <div class="bars-row">
      <div class="bar-wrap"><div class="bar-label"><span>‚ú® Mana</span><span id="b-mana-text">0/10</span></div><div class="bar bar-mana"><div class="bar-fill" id="b-mana-fill"></div></div></div>
      <div class="bar-wrap"><div class="bar-label"><span>üíÄ Ult</span><span id="b-ult-text">0%</span></div><div class="bar bar-ult"><div class="bar-fill" id="b-ult-fill" style="width:0"></div></div></div>
    </div>
    <div class="action-row">
      <button class="action-btn btn-skill" id="btn-skill" onclick="useSkill()" disabled>‚ö° SKILL</button>
      <button class="action-btn btn-ult" id="btn-ult" onclick="useUltimate()" disabled>üíÄ ULT</button>
      <button class="action-btn btn-potion" id="btn-potion" onclick="usePotion()" disabled>üß™ √ó<span id="potion-count">1</span></button>
    </div>
    <div class="info-row">
      <div class="relics-display" id="b-relics"></div>
      <div>üí∞ <span id="b-gold">0</span></div>
    </div>
  </div>
</div>

<!-- Reward -->
<div id="reward-screen" class="screen">
  <h2>‚ú® FLOOR CLEAR!</h2>
  <div class="sub" id="rw-sub">Choose your reward</div>
  <div class="reward-cards" id="rw-cards"></div>
  <button class="skip-btn" onclick="skipReward()">Skip ‚Üí</button>
</div>

<!-- Event -->
<div id="event-screen" class="screen">
  <h2 id="ev-title">üèïÔ∏è Rest</h2>
  <div class="event-choices" id="ev-choices"></div>
</div>

<!-- Game Over -->
<div id="gameover-screen" class="screen">
  <h2>üíÄ GAME OVER</h2>
  <div class="go-sub">The dungeon claims another soul...</div>
  <div class="go-stats">
    Reached Floor <span id="go-floor">1</span><br>
    Enemies Slain: <span id="go-kills">0</span><br>
    Chains: <span id="go-chains">0</span>
  </div>
  <div id="go-sp">+0 Soul Points</div>
  <button class="menu-btn" onclick="returnToTitle()">üè† Return</button>
</div>

<!-- Victory -->
<div id="victory-screen" class="screen">
  <h2>üèÜ VICTORY!</h2>
  <div class="go-sub" style="color:var(--gold)">You conquered the dungeon!</div>
  <div class="go-stats">
    Cleared all 25 floors!<br>
    Enemies Slain: <span id="v-kills">0</span>
  </div>
  <div id="v-sp">+0 Soul Points</div>
  <button class="menu-btn" onclick="returnToTitle()">üè† Return</button>
</div>

<!-- Upgrades -->
<div id="upgrade-screen" class="screen">
  <h2>‚¨ÜÔ∏è UPGRADES</h2>
  <div class="sp-display">‚ú® <span id="u-sp">0</span> Soul Points</div>
  <div class="upgrade-list" id="upgrade-list"></div>
  <button class="back-btn" onclick="showScreen('title-screen')">‚Üê Back</button>
</div>

<!-- Codex -->
<div id="codex-screen" class="screen">
  <h2>üìä CODEX</h2>
  <div id="codex-content"></div>
  <button class="back-btn" onclick="showScreen('title-screen')">‚Üê Back</button>
</div>

<button class="mute-fab" id="mute-btn" onclick="toggleMute()">üîä</button>
</div>

<script>
// ===== CONSTANTS =====
const GRID_SIZE = 6;
const GEM_TYPES = ['red','blue','green','yellow','purple'];
const GEM_EMOJI = {red:'üî¥',blue:'üîµ',green:'üü¢',yellow:'üü°',purple:'üü£',star:'‚≠ê',curse:'üíÄ'};
const GEM_LABELS = {red:'Attack',blue:'Shield',green:'Heal',yellow:'Mana',purple:'Ultimate'};

const HEROES = {
  warrior: {name:'Ï†ÑÏÇ¨',icon:'‚öîÔ∏è',hp:100,atk:12,def:8,mana:8,crit:10,
    passive:'4+ match: +50% damage',
    ultimate:'All Attack: 200% damage to enemy',
    skill:'Power Strike: 2√ó ATK damage (5 mana)',skillCost:5,
    unlockCost:0},
  mage: {name:'ÎßàÎ≤ïÏÇ¨',icon:'üßô',hp:70,atk:8,def:5,mana:15,crit:5,
    passive:'Yellow match: convert 1 random gem',
    ultimate:'Board reset + 150% ATK damage',
    skill:'Fireball: 3√ó ATK damage (7 mana)',skillCost:7,
    unlockCost:500},
  knight: {name:'Í∏∞ÏÇ¨',icon:'üõ°Ô∏è',hp:120,atk:6,def:14,mana:6,crit:5,
    passive:'Blue match: reflect 20% damage',
    ultimate:'Invincible for 3 turns',
    skill:'Shield Bash: ATK dmg + 10 shield (4 mana)',skillCost:4,
    unlockCost:800},
  rogue: {name:'ÎèÑÏ†Å',icon:'üó°Ô∏è',hp:80,atk:15,def:5,mana:10,crit:25,
    passive:'Chain match: guaranteed critical',
    ultimate:'Poison: 3-turn DoT (ATK√ó3 total)',
    skill:'Backstab: 2.5√ó ATK if enemy HP>50% (6 mana)',skillCost:6,
    unlockCost:1200}
};

const MONSTERS = [
  {name:'Ïä¨ÎùºÏûÑ',icon:'üü¢',floors:[1,5],hpMul:1,atkMul:1,pattern:'basic'},
  {name:'Í≥†Î∏îÎ¶∞',icon:'üë∫',floors:[1,6],hpMul:0.8,atkMul:1.3,pattern:'fast'},
  {name:'Î∞ïÏ•ê',icon:'ü¶á',floors:[2,7],hpMul:0.7,atkMul:1.1,pattern:'basic'},
  {name:'Ïä§ÏºàÎ†àÌÜ§',icon:'üíÄ',floors:[3,9],hpMul:1.2,atkMul:0.9,pattern:'defend'},
  {name:'ÎèÖÍ±∞ÎØ∏',icon:'üï∑Ô∏è',floors:[5,12],hpMul:1,atkMul:1,pattern:'poison'},
  {name:'Í≥®Î†ò',icon:'üóø',floors:[6,14],hpMul:2,atkMul:0.6,pattern:'tank'},
  {name:'Îã§ÌÅ¨ Î©îÏù¥ÏßÄ',icon:'üßô‚Äç‚ôÇÔ∏è',floors:[8,16],hpMul:1,atkMul:1.2,pattern:'curse'},
  {name:'Î±ÄÌååÏù¥Ïñ¥',icon:'üßõ',floors:[10,19],hpMul:1.3,atkMul:1.1,pattern:'lifesteal'},
  {name:'ÎìúÎûòÍ≥§',icon:'üêâ',floors:[15,25],hpMul:1.5,atkMul:1.4,pattern:'charge'},
  {name:'Î¶¨Ïπò',icon:'üëª',floors:[18,25],hpMul:1.2,atkMul:1.3,pattern:'curse'},
  {name:'Îç∞Î™¨ Î°úÎìú',icon:'üòà',floors:[20,25],hpMul:1.8,atkMul:1.5,pattern:'random'}
];

const BOSSES = {
  5:{name:'Í≥†Î∏îÎ¶∞ ÌÇπ',icon:'üëπ',hpMul:3,atkMul:1.5,pattern:'summon',phases:1},
  10:{name:'Î±ÄÌååÏù¥Ïñ¥ Î°úÎìú',icon:'üßõ‚Äç‚ôÇÔ∏è',hpMul:3.5,atkMul:1.5,pattern:'lifesteal_boss',phases:2},
  15:{name:'ÎìúÎûòÍ≥§ ÏóòÎçî',icon:'üê≤',hpMul:4,atkMul:1.8,pattern:'fire_breath',phases:2},
  20:{name:'Î¶¨Ïπò ÌÇπ',icon:'üíÄ',hpMul:5,atkMul:2,pattern:'necro',phases:3},
  25:{name:'Îç∞Î™¨ Ïò§Î≤ÑÎ°úÎìú',icon:'üëø',hpMul:6,atkMul:2.5,pattern:'final',phases:3}
};

const RELICS = [
  {id:'fire_ring',name:'ÌôîÏóº Î∞òÏßÄ',icon:'üî•',desc:'üî¥ Îß§Ïπò Îç∞ÎØ∏ÏßÄ +30%',effect:'red_dmg',value:0.3,tier:1},
  {id:'ice_crown',name:'ÏñºÏùå ÏôïÍ¥Ä',icon:'‚ùÑÔ∏è',desc:'üîµ Îß§Ïπò Ïãú Ïâ¥Îìú +5 Ï∂îÍ∞Ä',effect:'blue_bonus',value:5,tier:1},
  {id:'life_seed',name:'ÏÉùÎ™Ö Ïî®Ïïó',icon:'üå±',desc:'üü¢ Îß§Ïπò ÌöåÎ≥µÎüâ +40%',effect:'green_heal',value:0.4,tier:1},
  {id:'thunder_gem',name:'Î≤àÍ∞ú Î≥¥ÏÑù',icon:'‚ö°',desc:'üü° Îß§Ïπò Ïãú ÎßàÎÇò +2 Ï∂îÍ∞Ä',effect:'yellow_mana',value:2,tier:1},
  {id:'void_orb',name:'Í≥µÌóà Íµ¨Ï≤¥',icon:'üîÆ',desc:'üü£ Îß§Ïπò Ïãú Í∂ÅÍ∑πÍ∏∞ +10% Ï∂îÍ∞Ä',effect:'purple_ult',value:10,tier:1},
  {id:'vampire_fang',name:'Î±ÄÌååÏù¥Ïñ¥ ÏÜ°Í≥≥Îãà',icon:'ü¶∑',desc:'Í≥µÍ≤© Ïãú Îç∞ÎØ∏ÏßÄÏùò 15% ÌöåÎ≥µ',effect:'lifesteal',value:0.15,tier:2},
  {id:'berserker_axe',name:'Í¥ëÏ†ÑÏÇ¨ ÎèÑÎÅº',icon:'ü™ì',desc:'HP 50% Ïù¥Ìïò: Í≥µÍ≤©Î†• 2Î∞∞',effect:'berserker',value:2,tier:2},
  {id:'mirror_shield',name:'Í±∞Ïö∏ Î∞©Ìå®',icon:'ü™û',desc:'Î∞õÎäî Îç∞ÎØ∏ÏßÄ 20% Î∞òÏÇ¨',effect:'reflect',value:0.2,tier:2},
  {id:'lucky_coin',name:'ÌñâÏö¥Ïùò ÎèôÏ†Ñ',icon:'ü™ô',desc:'ÌÅ¨Î¶¨Ìã∞Ïª¨ ÌôïÎ•† +15%',effect:'crit_up',value:15,tier:1},
  {id:'chain_link',name:'Ïó∞ÏáÑ Í≥†Î¶¨',icon:'üîó',desc:'Ïó∞ÏáÑ Îß§Ïπò Î≥¥ÎÑàÏä§ +100%',effect:'chain_bonus',value:1,tier:2},
  {id:'mana_crystal',name:'ÎßàÎÇò ÏàòÏ†ï',icon:'üíé',desc:'Ï†ÑÌà¨ ÏãúÏûë Ïãú ÎßàÎÇò MAX',effect:'start_mana',value:1,tier:2},
  {id:'heart_locket',name:'ÏÉùÎ™Ö Î™©Í±∏Ïù¥',icon:'üíñ',desc:'ÏµúÎåÄ HP +25',effect:'max_hp',value:25,tier:1},
  {id:'poison_dagger',name:'ÎèÖ Îã®Í≤Ä',icon:'üó°Ô∏è',desc:'Í≥µÍ≤© Ïãú 15% ÌôïÎ•†Î°ú ÎèÖ(3ÌÑ¥)',effect:'poison_chance',value:0.15,tier:2},
  {id:'gold_idol',name:'Ìô©Í∏à Ïö∞ÏÉÅ',icon:'üèÜ',desc:'Ï†ÑÌà¨ ÏäπÎ¶¨ Í≥®Îìú +50%',effect:'gold_bonus',value:0.5,tier:1},
  {id:'star_compass',name:'Î≥Ñ ÎÇòÏπ®Î∞ò',icon:'üß≠',desc:'‚≠ê Ï∂úÌòÑ ÌôïÎ•† 2Î∞∞',effect:'star_chance',value:2,tier:2},
  {id:'phoenix_feather',name:'Î∂àÏÇ¨Ï°∞ ÍπÉÌÑ∏',icon:'ü™∂',desc:'ÏÇ¨Îßù Ïãú 1Ìöå Î∂ÄÌôú (HP 30%)',effect:'revive',value:1,tier:3},
  {id:'dragon_scale',name:'Ïö©Î¶∞',icon:'üêâ',desc:'Î∞õÎäî Îç∞ÎØ∏ÏßÄ -15%',effect:'damage_reduce',value:0.15,tier:2},
  {id:'cursed_mask',name:'Ï†ÄÏ£º Í∞ÄÎ©¥',icon:'üé≠',desc:'Í≥µÍ≤©Î†• +50%, Î∞õÎäî Îç∞ÎØ∏ÏßÄ +20%',effect:'glass_cannon',value:0.5,tier:3},
  {id:'healing_totem',name:'ÏπòÏú† ÌÜ†ÌÖú',icon:'üóø',desc:'Îß§ ÌÑ¥ HP 5 ÌöåÎ≥µ',effect:'regen',value:5,tier:2},
  {id:'combo_crown',name:'ÏΩ§Î≥¥ ÏôïÍ¥Ä',icon:'üëë',desc:'4+ Îß§Ïπò Ïãú Ï∂îÍ∞Ä ÌÑ¥',effect:'extra_turn',value:1,tier:3},
];

const UPGRADES = [
  {id:'start_hp',name:'ÏãúÏûë HP Í∞ïÌôî',desc:'+10 HP per level',maxLvl:5,costs:[100,200,400,800,1600],effect:'hp',value:10},
  {id:'start_gold',name:'ÏãúÏûë Í≥®Îìú Ï¶ùÍ∞Ä',desc:'+50 Gold per level',maxLvl:3,costs:[200,500,1000],effect:'gold',value:50},
  {id:'relic_slot',name:'Ïú†Î¨º Ïä¨Î°Ø ÌôïÏû•',desc:'+1 Relic slot',maxLvl:2,costs:[500,1500],effect:'relic',value:1},
  {id:'potion_slot',name:'Ìè¨ÏÖò Ïä¨Î°Ø Ï∂îÍ∞Ä',desc:'+1 Potion',maxLvl:2,costs:[300,700],effect:'potion',value:1},
  {id:'crit_up',name:'Í∏∞Î≥∏ ÌÅ¨Î¶¨Ìã∞Ïª¨',desc:'+5% Crit per level',maxLvl:3,costs:[200,500,1000],effect:'crit',value:5},
  {id:'unlock_mage',name:'ÎßàÎ≤ïÏÇ¨ Ìï¥Í∏à',desc:'Unlock üßô Mage class',maxLvl:1,costs:[500],effect:'unlock',value:'mage'},
  {id:'unlock_knight',name:'Í∏∞ÏÇ¨ Ìï¥Í∏à',desc:'Unlock üõ°Ô∏è Knight class',maxLvl:1,costs:[800],effect:'unlock',value:'knight'},
  {id:'unlock_rogue',name:'ÎèÑÏ†Å Ìï¥Í∏à',desc:'Unlock üó°Ô∏è Rogue class',maxLvl:1,costs:[1200],effect:'unlock',value:'rogue'}
];

// ===== GAME STATE =====
let meta = {
  soulPoints: 0,
  bestFloor: 0,
  totalRuns: 0,
  upgrades: {},
  unlockedHeroes: ['warrior'],
  codex: {monsters:[],relics:[],bosses:[]}
};

let run = null;
let battle = null;
let grid = [];
let selectedGem = null;
let animating = false;
let chainCount = 0;
let totalChains = 0;
let killCount = 0;
let selectedHero = null;

// ===== SOUND SYSTEM =====
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
let masterGain, bgmGain, sfxGain;
let bgmNodes = [];
let bgmPulseTimer = null;
let soundMuted = false;
let bgmPlaying = false;

function initAudio() {
  if (audioCtx) return;
  try {
    audioCtx = new AudioCtx();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;
    masterGain.connect(audioCtx.destination);
    bgmGain = audioCtx.createGain();
    bgmGain.gain.value = 0.25;
    bgmGain.connect(masterGain);
    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.5;
    sfxGain.connect(masterGain);
  } catch(e) {}
}

function ensureAudio() {
  if (!audioCtx) initAudio();
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}

function toggleMute() {
  ensureAudio();
  soundMuted = !soundMuted;
  if (masterGain) masterGain.gain.value = soundMuted ? 0 : 1;
  document.getElementById('mute-btn').textContent = soundMuted ? 'üîá' : 'üîä';
}

function playBGM() {
  ensureAudio();
  if (!audioCtx || bgmPlaying) return;
  stopBGM();
  bgmPlaying = true;
  const now = audioCtx.currentTime;
  // Dark dungeon drone
  const osc1 = audioCtx.createOscillator();
  const g1 = audioCtx.createGain();
  osc1.type = 'sawtooth'; osc1.frequency.value = 55;
  g1.gain.value = 0.12;
  osc1.connect(g1); g1.connect(bgmGain);
  // Sub bass
  const osc2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  osc2.type = 'sine'; osc2.frequency.value = 36.7;
  g2.gain.value = 0.18;
  osc2.connect(g2); g2.connect(bgmGain);
  // Eerie pad with LFO wobble
  const osc3 = audioCtx.createOscillator();
  const g3 = audioCtx.createGain();
  osc3.type = 'triangle'; osc3.frequency.value = 130.8;
  g3.gain.value = 0.06;
  const lfo = audioCtx.createOscillator();
  const lfoG = audioCtx.createGain();
  lfo.frequency.value = 0.3; lfoG.gain.value = 5;
  lfo.connect(lfoG); lfoG.connect(osc3.frequency);
  osc3.connect(g3); g3.connect(bgmGain);
  // Filtered dissonant tone
  const filt = audioCtx.createBiquadFilter();
  filt.type = 'lowpass'; filt.frequency.value = 400; filt.Q.value = 2;
  const osc4 = audioCtx.createOscillator();
  const g4 = audioCtx.createGain();
  osc4.type = 'sine'; osc4.frequency.value = 311;
  g4.gain.value = 0.03;
  osc4.connect(g4); g4.connect(filt); filt.connect(bgmGain);
  // Rhythmic pulse
  const osc5 = audioCtx.createOscillator();
  const g5 = audioCtx.createGain();
  osc5.type = 'sine'; osc5.frequency.value = 82.4;
  g5.gain.value = 0;
  osc5.connect(g5); g5.connect(bgmGain);
  const pulseLoop = () => {
    if (!audioCtx || audioCtx.state === 'closed' || !bgmPlaying) return;
    const t = audioCtx.currentTime;
    g5.gain.cancelScheduledValues(t);
    for (let i = 0; i < 16; i++) {
      g5.gain.setValueAtTime(0, t + i * 2);
      g5.gain.linearRampToValueAtTime(0.1, t + i * 2 + 0.1);
      g5.gain.linearRampToValueAtTime(0, t + i * 2 + 1.5);
    }
    bgmPulseTimer = setTimeout(pulseLoop, 32000);
  };
  [osc1, osc2, osc3, osc4, osc5, lfo].forEach(o => o.start(now));
  bgmNodes = [osc1, osc2, osc3, osc4, osc5, lfo, g1, g2, g3, g4, g5, lfoG, filt];
  pulseLoop();
}

function stopBGM() {
  bgmPlaying = false;
  if (bgmPulseTimer) { clearTimeout(bgmPulseTimer); bgmPulseTimer = null; }
  bgmNodes.forEach(n => { try { if (n.stop) n.stop(); n.disconnect(); } catch(e){} });
  bgmNodes = [];
}

function playSFX(type) {
  ensureAudio();
  if (!audioCtx || soundMuted) return;
  const now = audioCtx.currentTime;
  const sfx = {
    attack() {
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2-1)*Math.exp(-i/(d.length*0.3));
      const s = audioCtx.createBufferSource(); s.buffer = buf;
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=2000;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.4,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.15);
      s.connect(hp); hp.connect(g); g.connect(sfxGain); s.start(now);
    },
    magic() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.setValueAtTime(400,now); o.frequency.exponentialRampToValueAtTime(1200,now+0.2);
      g.gain.setValueAtTime(0.25,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.3);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.3);
      const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
      o2.type='triangle'; o2.frequency.setValueAtTime(800,now); o2.frequency.exponentialRampToValueAtTime(2400,now+0.25);
      g2.gain.setValueAtTime(0.1,now); g2.gain.exponentialRampToValueAtTime(0.01,now+0.25);
      o2.connect(g2); g2.connect(sfxGain); o2.start(now); o2.stop(now+0.25);
    },
    hit() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.setValueAtTime(150,now); o.frequency.exponentialRampToValueAtTime(40,now+0.2);
      g.gain.setValueAtTime(0.5,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.2);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.2);
    },
    item() {
      [523,659,784].forEach((f,i) => {
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type='sine'; o.frequency.value=f;
        g.gain.setValueAtTime(0,now+i*0.08); g.gain.linearRampToValueAtTime(0.2,now+i*0.08+0.02);
        g.gain.exponentialRampToValueAtTime(0.01,now+i*0.08+0.15);
        o.connect(g); g.connect(sfxGain); o.start(now+i*0.08); o.stop(now+i*0.08+0.15);
      });
    },
    levelup() {
      [262,330,392,523,659].forEach((f,i) => {
        const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
        o.type='triangle'; o.frequency.value=f;
        g.gain.setValueAtTime(0,now+i*0.1); g.gain.linearRampToValueAtTime(0.25,now+i*0.1+0.03);
        g.gain.exponentialRampToValueAtTime(0.01,now+i*0.1+0.3);
        o.connect(g); g.connect(sfxGain); o.start(now+i*0.1); o.stop(now+i*0.1+0.3);
      });
    },
    door() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='triangle'; o.frequency.setValueAtTime(100,now); o.frequency.linearRampToValueAtTime(200,now+0.3);
      g.gain.setValueAtTime(0.3,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.5);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.5);
      const o2 = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
      o2.type='sine'; o2.frequency.value=523;
      g2.gain.setValueAtTime(0.2,now+0.1); g2.gain.exponentialRampToValueAtTime(0.01,now+0.5);
      o2.connect(g2); g2.connect(sfxGain); o2.start(now+0.1); o2.stop(now+0.5);
    },
    death() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sawtooth'; o.frequency.setValueAtTime(200,now); o.frequency.exponentialRampToValueAtTime(30,now+1);
      g.gain.setValueAtTime(0.3,now); g.gain.linearRampToValueAtTime(0,now+1);
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=500;
      o.connect(lp); lp.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+1);
    },
    shield() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='square'; o.frequency.setValueAtTime(800,now); o.frequency.exponentialRampToValueAtTime(400,now+0.1);
      g.gain.setValueAtTime(0.15,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.15);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.15);
    },
    heal() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.setValueAtTime(300,now); o.frequency.linearRampToValueAtTime(600,now+0.3);
      g.gain.setValueAtTime(0.2,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.4);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.4);
    },
    match() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.setValueAtTime(600+Math.random()*200,now);
      g.gain.setValueAtTime(0.15,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.1);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.1);
    },
    chain() {
      const pitch = 400 + chainCount * 100;
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='triangle'; o.frequency.value=pitch;
      g.gain.setValueAtTime(0.2,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.2);
      o.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.2);
    },
    crit() {
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate*0.1, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/(d.length*0.2));
      const s = audioCtx.createBufferSource(); s.buffer=buf;
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.5,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.1);
      s.connect(g); g.connect(sfxGain); s.start(now);
      const o = audioCtx.createOscillator(); const g2 = audioCtx.createGain();
      o.type='sine'; o.frequency.value=1500;
      g2.gain.setValueAtTime(0.2,now); g2.gain.exponentialRampToValueAtTime(0.01,now+0.3);
      o.connect(g2); g2.connect(sfxGain); o.start(now); o.stop(now+0.3);
    },
    enemy_hit() {
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sawtooth'; o.frequency.setValueAtTime(200,now); o.frequency.exponentialRampToValueAtTime(80,now+0.15);
      g.gain.setValueAtTime(0.3,now); g.gain.exponentialRampToValueAtTime(0.01,now+0.2);
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=800;
      o.connect(lp); lp.connect(g); g.connect(sfxGain); o.start(now); o.stop(now+0.2);
    }
  };
  if (sfx[type]) sfx[type]();
}

// ===== DB =====
let db = null;
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open('PuzzleRogueDungeon', 1);
    req.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('meta')) d.createObjectStore('meta');
    };
    req.onsuccess = e => { db = e.target.result; resolve(); };
    req.onerror = () => resolve(); // continue without DB
  });
}
async function saveMeta() {
  if (!db) return;
  try {
    const tx = db.transaction('meta', 'readwrite');
    tx.objectStore('meta').put(meta, 'save');
  } catch(e) {}
}
async function loadMeta() {
  if (!db) return;
  return new Promise(resolve => {
    try {
      const tx = db.transaction('meta', 'readonly');
      const req = tx.objectStore('meta').get('save');
      req.onsuccess = () => { if (req.result) meta = req.result; resolve(); };
      req.onerror = () => resolve();
    } catch(e) { resolve(); }
  });
}

// ===== SCREENS =====
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if (id === 'title-screen') updateTitleStats();
  if (id === 'hero-screen') renderHeroSelect();
  if (id === 'upgrade-screen') renderUpgrades();
  if (id === 'codex-screen') renderCodex();
}

function updateTitleStats() {
  document.getElementById('s-best').textContent = meta.bestFloor;
  document.getElementById('s-runs').textContent = meta.totalRuns;
  document.getElementById('s-sp').textContent = meta.soulPoints;
}

// ===== HERO SELECT =====
function renderHeroSelect() {
  const g = document.getElementById('hero-grid');
  g.innerHTML = '';
  Object.entries(HEROES).forEach(([key, h]) => {
    const unlocked = meta.unlockedHeroes.includes(key);
    const card = document.createElement('div');
    card.className = 'hero-card' + (key === selectedHero ? ' selected' : '') + (!unlocked ? ' locked' : '');
    card.innerHTML = `
      <div class="hero-icon">${h.icon}</div>
      <div class="hero-name">${h.name}</div>
      <div class="hero-stats">
        HP: ${h.hp} | ATK: ${h.atk}<br>
        DEF: ${h.def} | MANA: ${h.mana}<br>
        CRIT: ${h.crit}%<br>
        <em style="color:#888;font-size:.85em">${h.passive}</em>
      </div>
      ${!unlocked ? '<div style="color:var(--red);margin-top:.5em">üîí Locked</div>' : ''}
    `;
    if (unlocked) {
      card.onclick = () => {
        selectedHero = key;
        renderHeroSelect();
        document.getElementById('start-run').disabled = false;
      };
    }
    g.appendChild(card);
  });
}

// ===== START RUN =====
function startRun() {
  if (!selectedHero) return;
  ensureAudio(); playBGM();
  const h = HEROES[selectedHero];
  const hpBonus = getUpgradeLevel('start_hp') * 10;
  const goldBonus = getUpgradeLevel('start_gold') * 50;
  const relicSlots = 4 + getUpgradeLevel('relic_slot');
  const potions = 1 + getUpgradeLevel('potion_slot');
  const critBonus = getUpgradeLevel('crit_up') * 5;

  run = {
    floor: 1,
    heroKey: selectedHero,
    hero: {...h},
    hp: h.hp + hpBonus,
    maxHp: h.hp + hpBonus,
    mana: 0,
    maxMana: h.mana,
    gold: goldBonus,
    shield: 0,
    ultimateGauge: 0,
    relics: [],
    relicSlots: relicSlots,
    potions: potions,
    maxPotions: potions,
    crit: h.crit + critBonus,
    invincibleTurns: 0,
    poisonOnEnemy: 0,
    reviveUsed: false,
    extraTurn: false
  };

  // Mana crystal relic check (from previous relics -- fresh run has none)
  killCount = 0;
  totalChains = 0;
  meta.totalRuns++;
  saveMeta();

  startFloor();
}

function getUpgradeLevel(id) {
  return meta.upgrades[id] || 0;
}

// ===== FLOOR =====
function startFloor() {
  const floor = run.floor;
  const isBoss = BOSSES[floor];

  let enemy;
  if (isBoss) {
    const b = BOSSES[floor];
    const baseHp = 50 + floor * 20;
    enemy = {
      name: b.name,
      icon: b.icon,
      hp: Math.floor(baseHp * b.hpMul),
      maxHp: Math.floor(baseHp * b.hpMul),
      atk: Math.floor((5 + floor * 2) * b.atkMul),
      pattern: b.pattern,
      phases: b.phases,
      currentPhase: 1,
      isBoss: true,
      turnCount: 0,
      debuffs: [],
      chargeTimer: 0
    };
    if (!meta.codex.bosses.includes(b.name)) {
      meta.codex.bosses.push(b.name);
      saveMeta();
    }
  } else {
    const eligible = MONSTERS.filter(m => floor >= m.floors[0] && floor <= m.floors[1]);
    const m = eligible[Math.floor(Math.random() * eligible.length)] || MONSTERS[0];
    const baseHp = 50 + floor * 20 + Math.floor(Math.random() * floor * 5);
    enemy = {
      name: m.name,
      icon: m.icon,
      hp: Math.floor(baseHp * m.hpMul),
      maxHp: Math.floor(baseHp * m.hpMul),
      atk: Math.floor((5 + floor * 2) * m.atkMul),
      pattern: m.pattern,
      isBoss: false,
      turnCount: 0,
      debuffs: [],
      chargeTimer: 0
    };
    if (!meta.codex.monsters.includes(m.name)) {
      meta.codex.monsters.push(m.name);
      saveMeta();
    }
  }

  battle = {
    enemy: enemy,
    turnCount: 0,
    intent: generateIntent(enemy, 0)
  };

  // Mana crystal relic
  if (hasRelic('mana_crystal')) {
    run.mana = run.maxMana;
  }
  // Regen
  if (hasRelic('healing_totem')) {
    run.hp = Math.min(run.maxHp, run.hp + 5);
  }

  initGrid();
  showScreen('battle-screen');
  updateBattleUI();
}

function generateIntent(enemy, turn) {
  const p = enemy.pattern;
  if (p === 'basic') return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'fast') return turn % 2 === 0 ? {type:'attack',value:Math.floor(enemy.atk*1.5),label:`‚öîÔ∏è Quick ${Math.floor(enemy.atk*1.5)} dmg`} : {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'defend') return turn % 3 === 0 ? {type:'defend',value:0,label:'üõ°Ô∏è Defending...'} : {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'poison') return turn % 2 === 0 ? {type:'poison',value:Math.floor(enemy.atk*0.5),label:`üü¢ Poison ${Math.floor(enemy.atk*0.5)}/turn`} : {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'tank') return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Slow ${enemy.atk} dmg`};
  if (p === 'curse') return turn % 3 === 0 ? {type:'curse',value:2,label:'üíÄ Curse: +2 curse gems'} : {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'lifesteal') {const d=enemy.atk; return {type:'lifesteal',value:d,label:`üßõ Drain ${d} dmg (+heal)`};}
  if (p === 'charge') {
    if (enemy.chargeTimer > 0) {enemy.chargeTimer--; return {type:'attack',value:enemy.atk*3,label:`üî• Fire Breath! ${enemy.atk*3} dmg`};}
    if (turn % 4 === 0) {enemy.chargeTimer = 1; return {type:'none',value:0,label:'üî• Charging fire...'};}
    return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  }
  if (p === 'random') {
    const r = Math.random();
    if (r < 0.3) return {type:'attack',value:Math.floor(enemy.atk*1.5),label:`‚öîÔ∏è Power ${Math.floor(enemy.atk*1.5)} dmg`};
    if (r < 0.5) return {type:'poison',value:Math.floor(enemy.atk*0.4),label:`üü¢ Poison ${Math.floor(enemy.atk*0.4)}/turn`};
    if (r < 0.7) return {type:'curse',value:1,label:'üíÄ Curse: +1 curse gem'};
    return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  }
  // Boss patterns
  if (p === 'summon') return turn % 3 === 0 ? {type:'curse',value:3,label:'üíÄ Summon: +3 curse gems'} : {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  if (p === 'lifesteal_boss') {
    if (turn % 4 === 0) return {type:'lifesteal',value:Math.floor(enemy.atk*1.5),label:`üßõ Mega Drain ${Math.floor(enemy.atk*1.5)} dmg`};
    if (turn % 4 === 2) return {type:'curse',value:2,label:'üíÄ Dark Curse: +2'};
    return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
  }
  if (p === 'fire_breath') {
    if (turn % 5 === 0) {enemy.chargeTimer=1; return {type:'none',value:0,label:'üî• Charging mega fire...'};}
    if (enemy.chargeTimer > 0) {enemy.chargeTimer=0; return {type:'attack',value:enemy.atk*4,label:`üî• MEGA FIRE ${enemy.atk*4} dmg!`};}
    return turn%2===0 ? {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Claw ${enemy.atk} dmg`} : {type:'curse',value:1,label:'üíÄ Scorching: +1 curse'};
  }
  if (p === 'necro') {
    if (turn % 3 === 0) return {type:'curse',value:3,label:'üíÄ Necro: +3 curse gems'};
    if (turn % 5 === 0) return {type:'heal_self',value:Math.floor(enemy.maxHp*0.1),label:`üíö Self Heal ${Math.floor(enemy.maxHp*0.1)}`};
    return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Death Touch ${enemy.atk} dmg`};
  }
  if (p === 'final') {
    const phase = enemy.currentPhase || 1;
    if (phase >= 2 && turn % 3 === 0) return {type:'curse',value:4,label:'üíÄ Abyss: +4 curse gems'};
    if (phase >= 3 && turn % 5 === 0) return {type:'attack',value:enemy.atk*3,label:`üëø DOOM ${enemy.atk*3} dmg!`};
    if (turn % 2 === 0) return {type:'attack',value:Math.floor(enemy.atk*1.2),label:`‚öîÔ∏è Strike ${Math.floor(enemy.atk*1.2)} dmg`};
    return {type:'poison',value:Math.floor(enemy.atk*0.3),label:`üü¢ Dark Poison ${Math.floor(enemy.atk*0.3)}/turn`};
  }
  return {type:'attack',value:enemy.atk,label:`‚öîÔ∏è Attack ${enemy.atk} dmg`};
}

// ===== GRID =====
function initGrid() {
  grid = [];
  for (let r = 0; r < GRID_SIZE; r++) {
    grid[r] = [];
    for (let c = 0; c < GRID_SIZE; c++) {
      grid[r][c] = randomGem(r, c);
    }
  }
  // Remove initial matches
  let safety = 0;
  while (findMatches().length > 0 && safety < 100) {
    for (let r = 0; r < GRID_SIZE; r++)
      for (let c = 0; c < GRID_SIZE; c++)
        grid[r][c] = randomGem(r, c);
    safety++;
  }
  renderGrid();
}

function randomGem(r, c) {
  const starChance = hasRelic('star_compass') ? 0.06 : 0.03;
  if (Math.random() < starChance) return 'star';
  return GEM_TYPES[Math.floor(Math.random() * GEM_TYPES.length)];
}

function renderGrid() {
  const g = document.getElementById('grid');
  g.innerHTML = '';
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const gem = document.createElement('div');
      gem.className = `gem gem-${grid[r][c]}`;
      gem.textContent = GEM_EMOJI[grid[r][c]] || '?';
      gem.dataset.r = r;
      gem.dataset.c = c;
      if (selectedGem && selectedGem.r === r && selectedGem.c === c) gem.classList.add('selected');
      gem.addEventListener('pointerdown', e => onGemClick(r, c, e));
      g.appendChild(gem);
    }
  }
}

// Touch/swipe handling
let touchStart = null;
document.getElementById('grid-container').addEventListener('touchmove', e => e.preventDefault(), {passive:false});

function onGemClick(r, c, e) {
  if (animating) return;
  if (grid[r][c] === 'curse') return; // Can't select curse gems

  if (!selectedGem) {
    selectedGem = {r, c};
    renderGrid();
    // Setup swipe
    touchStart = {x: e.clientX || e.touches?.[0]?.clientX, y: e.clientY || e.touches?.[0]?.clientY, r, c};
    const onMove = (ev) => {
      if (!touchStart) return;
      const cx = ev.clientX || ev.touches?.[0]?.clientX;
      const cy = ev.clientY || ev.touches?.[0]?.clientY;
      const dx = cx - touchStart.x;
      const dy = cy - touchStart.y;
      const dist = Math.sqrt(dx*dx+dy*dy);
      if (dist > 25) {
        let tr, tc;
        if (Math.abs(dx) > Math.abs(dy)) {
          tr = touchStart.r; tc = touchStart.c + (dx > 0 ? 1 : -1);
        } else {
          tr = touchStart.r + (dy > 0 ? 1 : -1); tc = touchStart.c;
        }
        if (tr >= 0 && tr < GRID_SIZE && tc >= 0 && tc < GRID_SIZE) {
          touchStart = null;
          document.removeEventListener('pointermove', onMove);
          document.removeEventListener('pointerup', onUp);
          trySwap(selectedGem.r, selectedGem.c, tr, tc);
        }
      }
    };
    const onUp = () => {
      touchStart = null;
      document.removeEventListener('pointermove', onMove);
      document.removeEventListener('pointerup', onUp);
    };
    document.addEventListener('pointermove', onMove);
    document.addEventListener('pointerup', onUp);
  } else {
    const dr = Math.abs(r - selectedGem.r);
    const dc = Math.abs(c - selectedGem.c);
    if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
      trySwap(selectedGem.r, selectedGem.c, r, c);
    } else {
      selectedGem = {r, c};
      renderGrid();
    }
  }
}

async function trySwap(r1, c1, r2, c2) {
  animating = true;
  selectedGem = null;

  // Swap
  [grid[r1][c1], grid[r2][c2]] = [grid[r2][c2], grid[r1][c1]];
  renderGrid();

  const matches = findMatches();
  if (matches.length === 0) {
    // Swap back
    await sleep(200);
    [grid[r1][c1], grid[r2][c2]] = [grid[r2][c2], grid[r1][c1]];
    renderGrid();
    animating = false;
    return;
  }

  // Process matches
  chainCount = 0;
  await processMatches();
  
  // After player turn, check if extra turn
  if (run.extraTurn) {
    run.extraTurn = false;
    animating = false;
    updateBattleUI();
    return;
  }

  // Enemy turn
  await enemyTurn();
  
  // Check game state
  if (run.hp <= 0) {
    // Check revive
    if (hasRelic('phoenix_feather') && !run.reviveUsed) {
      run.reviveUsed = true;
      run.hp = Math.floor(run.maxHp * 0.3);
      floatText('ü™∂ REVIVE!', 'var(--gold)');
      await sleep(500);
    } else {
      gameOver();
      return;
    }
  }
  
  if (battle.enemy.hp <= 0) {
    floorCleared();
    return;
  }

  animating = false;
  updateBattleUI();
}

function findMatches() {
  const matched = new Set();
  // Horizontal
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE - 2; c++) {
      const t = grid[r][c];
      if (t === 'curse') continue;
      let len = 1;
      while (c + len < GRID_SIZE && (grid[r][c+len] === t || grid[r][c+len] === 'star' || t === 'star')) {
        // If star, match with the first non-star
        if (t === 'star' && grid[r][c+len] !== 'star') {
          // need at least 3 of same or star combo
        }
        len++;
      }
      // Simplified: check consecutive same (including star as wildcard)
      // Reset and do simpler check
      len = 1;
      // ignore star complexity for now, treat star as matching anything
      while (c + len < GRID_SIZE) {
        const next = grid[r][c+len];
        if (next === 'curse') break;
        if (next === t || next === 'star' || t === 'star') len++;
        else break;
      }
      if (len >= 3) {
        for (let i = 0; i < len; i++) matched.add(`${r},${c+i}`);
        c += len - 1; // skip matched gems
      }
    }
  }
  // Vertical
  for (let c = 0; c < GRID_SIZE; c++) {
    for (let r = 0; r < GRID_SIZE - 2; r++) {
      const t = grid[r][c];
      if (t === 'curse') continue;
      let len = 1;
      while (r + len < GRID_SIZE) {
        const next = grid[r+len][c];
        if (next === 'curse') break;
        if (next === t || next === 'star' || t === 'star') len++;
        else break;
      }
      if (len >= 3) {
        for (let i = 0; i < len; i++) matched.add(`${r+i},${c}`);
        r += len - 1;
      }
    }
  }
  return [...matched].map(s => {const [r,c] = s.split(',').map(Number); return {r,c,type:grid[r][c]};});
}

async function processMatches() {
  let matches = findMatches();
  while (matches.length > 0) {
    chainCount++;
    totalChains = Math.max(totalChains, chainCount);

    // Count gem types
    const counts = {};
    let matchLen = matches.length;
    matches.forEach(m => {
      const t = m.type === 'star' ? 'star' : m.type;
      counts[t] = (counts[t] || 0) + 1;
    });

    // Show chain
    if (chainCount > 1) {
      showChainPopup(chainCount);
      playSFX('chain');
    } else {
      playSFX('match');
    }

    // Apply match effects
    applyMatchEffects(counts, matchLen, chainCount);

    // Animate removal
    const gems = document.querySelectorAll('.gem');
    matches.forEach(m => {
      const idx = m.r * GRID_SIZE + m.c;
      if (gems[idx]) gems[idx].classList.add('matched');
    });
    await sleep(300);

    // Remove matched gems
    matches.forEach(m => grid[m.r][m.c] = null);

    // Drop gems
    for (let c = 0; c < GRID_SIZE; c++) {
      let writeRow = GRID_SIZE - 1;
      for (let r = GRID_SIZE - 1; r >= 0; r--) {
        if (grid[r][c] !== null) {
          if (r !== writeRow) {
            grid[writeRow][c] = grid[r][c];
            grid[r][c] = null;
          }
          writeRow--;
        }
      }
      // Fill empty with new gems
      for (let r = writeRow; r >= 0; r--) {
        grid[r][c] = randomGem(r, c);
      }
    }

    renderGrid();
    await sleep(300);

    // Check for new matches
    matches = findMatches();
    
    // Extra turn check (combo crown)
    if (chainCount >= 2 && hasRelic('combo_crown')) {
      run.extraTurn = true;
    }
  }

  updateBattleUI();
}

function applyMatchEffects(counts, total, chain) {
  const hero = run.hero;
  const chainMul = 1 + (chain - 1) * 0.5 * (1 + (hasRelic('chain_bonus') ? 1 : 0));
  const bigMatchBonus = total >= 4 ? 1.5 : 1;
  const megaBonus = total >= 5 ? 2.0 : bigMatchBonus;

  // Red = attack
  if (counts.red || counts.star) {
    let redCount = (counts.red || 0) + (counts.star || 0);
    let dmg = Math.floor(redCount * hero.atk * chainMul * megaBonus);
    
    // Relic: fire ring
    if (hasRelic('fire_ring')) dmg = Math.floor(dmg * 1.3);
    // Relic: berserker
    if (hasRelic('berserker_axe') && run.hp <= run.maxHp * 0.5) dmg *= 2;
    // Relic: glass cannon
    if (hasRelic('cursed_mask')) dmg = Math.floor(dmg * 1.5);
    // Warrior passive: 4+ match bonus
    if (run.heroKey === 'warrior' && total >= 4) dmg = Math.floor(dmg * 1.5);
    // Rogue passive: chain crit
    let crit = false;
    if (run.heroKey === 'rogue' && chain > 1) {
      crit = true;
    } else if (Math.random() * 100 < run.crit + (hasRelic('lucky_coin') ? 15 : 0)) {
      crit = true;
    }
    if (crit) {
      dmg *= 2;
      floatText(`üí• CRIT! ${dmg}`, 'var(--red)');
      playSFX('crit');
    } else {
      floatText(`‚öîÔ∏è ${dmg}`, 'var(--red)');
      playSFX('attack');
    }

    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    
    // Lifesteal relic
    if (hasRelic('vampire_fang')) {
      const heal = Math.floor(dmg * 0.15);
      run.hp = Math.min(run.maxHp, run.hp + heal);
    }
    // Poison dagger
    if (hasRelic('poison_dagger') && Math.random() < 0.15) {
      battle.enemy.debuffs.push({type:'poison',turns:3,value:Math.floor(hero.atk*0.5)});
    }
  }

  // Blue = shield
  if (counts.blue) {
    let shield = Math.floor(counts.blue * hero.def * chainMul);
    if (hasRelic('ice_crown')) shield += 5;
    run.shield += shield;
    floatText(`üõ°Ô∏è +${shield}`, 'var(--blue)');
    playSFX('shield');
    
    // Knight passive: reflect
    if (run.heroKey === 'knight') {
      // stored for next enemy attack
    }
  }

  // Green = heal
  if (counts.green) {
    let heal = Math.floor(counts.green * 5 * chainMul);
    if (hasRelic('life_seed')) heal = Math.floor(heal * 1.4);
    run.hp = Math.min(run.maxHp, run.hp + heal);
    floatText(`üíö +${heal}`, 'var(--green)');
    playSFX('heal');
  }

  // Yellow = mana
  if (counts.yellow) {
    let mana = counts.yellow + (hasRelic('thunder_gem') ? 2 : 0);
    run.mana = Math.min(run.maxMana, run.mana + Math.floor(mana * chainMul));
    floatText(`‚ú® +${mana} mana`, 'var(--yellow)');
    
    // Mage passive: convert random gem
    if (run.heroKey === 'mage') {
      const empties = [];
      for (let r = 0; r < GRID_SIZE; r++)
        for (let c = 0; c < GRID_SIZE; c++)
          if (grid[r][c] !== 'curse' && grid[r][c] !== 'star')
            empties.push({r,c});
      if (empties.length > 0) {
        const pick = empties[Math.floor(Math.random() * empties.length)];
        grid[pick.r][pick.c] = 'red'; // Convert to attack gem
      }
    }
  }

  // Purple = ult charge
  if (counts.purple) {
    let ult = counts.purple * 8 + (hasRelic('void_orb') ? 10 : 0);
    run.ultimateGauge = Math.min(100, run.ultimateGauge + Math.floor(ult * chainMul));
    floatText(`üíÄ +${ult}% ult`, 'var(--purple)');
  }

  // Boss phase check
  if (battle.enemy.isBoss && battle.enemy.phases > 1) {
    const hpPercent = battle.enemy.hp / battle.enemy.maxHp;
    if (battle.enemy.currentPhase === 1 && hpPercent <= 0.5) {
      battle.enemy.currentPhase = 2;
      floatText('‚ö†Ô∏è PHASE 2!', 'var(--gold)');
      battle.enemy.atk = Math.floor(battle.enemy.atk * 1.3);
    }
    if (battle.enemy.phases >= 3 && battle.enemy.currentPhase === 2 && hpPercent <= 0.25) {
      battle.enemy.currentPhase = 3;
      floatText('‚ö†Ô∏è PHASE 3!', 'var(--red)');
      battle.enemy.atk = Math.floor(battle.enemy.atk * 1.2);
    }
  }
}

// ===== ENEMY TURN =====
async function enemyTurn() {
  if (battle.enemy.hp <= 0) return;

  const intent = battle.intent;
  const enemy = battle.enemy;
  
  // Apply enemy debuffs first (poison on enemy)
  let poisonDmg = 0;
  enemy.debuffs = enemy.debuffs.filter(d => {
    if (d.type === 'poison') {
      poisonDmg += d.value;
      d.turns--;
      return d.turns > 0;
    }
    return true;
  });
  if (poisonDmg > 0) {
    enemy.hp = Math.max(0, enemy.hp - poisonDmg);
    floatText(`üü¢ Poison ${poisonDmg}`, '#27ae60', true);
    await sleep(300);
  }
  if (enemy.hp <= 0) return;

  // Run poison on player
  if (run.poisonOnEnemy > 0) {
    // This is player poison FROM enemy, separate
  }

  // Execute intent
  if (intent.type === 'attack' || intent.type === 'lifesteal') {
    let dmg = intent.value;
    // Damage reduce relic
    if (hasRelic('dragon_scale')) dmg = Math.floor(dmg * 0.85);
    if (hasRelic('cursed_mask')) dmg = Math.floor(dmg * 1.2);
    
    // Invincible
    if (run.invincibleTurns > 0) {
      floatText('üõ°Ô∏è INVINCIBLE!', 'var(--gold)');
      dmg = 0;
    }

    // Shield absorb
    if (run.shield > 0) {
      const absorbed = Math.min(run.shield, dmg);
      run.shield -= absorbed;
      dmg -= absorbed;
      if (absorbed > 0) floatText(`üõ°Ô∏è -${absorbed}`, 'var(--blue)');
    }

    if (dmg > 0) {
      run.hp -= dmg;
      floatText(`üíî -${dmg}`, 'var(--red)');
      playSFX('enemy_hit');
      document.getElementById('battle-screen').classList.add('shake');
      setTimeout(() => document.getElementById('battle-screen').classList.remove('shake'), 300);
      
      // Knight reflect
      if (run.heroKey === 'knight' && run.shield > 0) {
        const reflect = Math.floor(intent.value * 0.2);
        enemy.hp = Math.max(0, enemy.hp - reflect);
        floatText(`ü™û Reflect ${reflect}`, 'var(--blue)', true);
      }
      // Mirror shield relic
      if (hasRelic('mirror_shield')) {
        const reflect = Math.floor(intent.value * 0.2);
        enemy.hp = Math.max(0, enemy.hp - reflect);
      }
    }

    // Lifesteal
    if (intent.type === 'lifesteal') {
      const heal = Math.floor(intent.value * 0.3);
      enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
    }
  } else if (intent.type === 'poison') {
    // Apply poison to player -- we track as simple DoT
    run.hp -= intent.value;
    floatText(`üü¢ Poison! -${intent.value}`, '#27ae60');
    // Also ongoing
    battle.playerPoison = (battle.playerPoison || 0) + intent.value;
  } else if (intent.type === 'curse') {
    // Add curse gems to grid
    const count = intent.value;
    for (let i = 0; i < count; i++) {
      const empties = [];
      for (let r = 0; r < GRID_SIZE; r++)
        for (let c = 0; c < GRID_SIZE; c++)
          if (grid[r][c] !== 'curse') empties.push({r,c});
      if (empties.length > 0) {
        const pick = empties[Math.floor(Math.random() * empties.length)];
        grid[pick.r][pick.c] = 'curse';
      }
    }
    renderGrid();
    floatText(`üíÄ +${count} Curse!`, '#555');
  } else if (intent.type === 'heal_self') {
    enemy.hp = Math.min(enemy.maxHp, enemy.hp + intent.value);
    floatText(`üíö Enemy +${intent.value}`, '#27ae60', true);
  }
  // type 'none' or 'defend' = skip

  // Player poison damage (ongoing)
  if (battle.playerPoison > 0) {
    run.hp -= Math.floor(battle.playerPoison * 0.5);
    battle.playerPoison = Math.max(0, battle.playerPoison - 2);
  }

  // Regen relic
  if (hasRelic('healing_totem')) {
    run.hp = Math.min(run.maxHp, run.hp + 5);
  }

  // Decrease invincible
  if (run.invincibleTurns > 0) run.invincibleTurns--;

  // Next intent
  battle.turnCount++;
  enemy.turnCount++;
  battle.intent = generateIntent(enemy, enemy.turnCount);
  
  await sleep(400);
  updateBattleUI();
}

// ===== SKILLS =====
function useSkill() {
  if (animating) return;
  const key = run.heroKey;
  const h = HEROES[key];
  if (run.mana < h.skillCost) return;
  run.mana -= h.skillCost;

  if (key === 'warrior') {
    const dmg = run.hero.atk * 2;
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    floatText(`‚ö° Power Strike! ${dmg}`, 'var(--gold)');
    playSFX('attack');
  } else if (key === 'mage') {
    const dmg = run.hero.atk * 3;
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    floatText(`üî• Fireball! ${dmg}`, '#e74c3c');
    playSFX('magic');
  } else if (key === 'knight') {
    const dmg = run.hero.atk;
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    run.shield += 10;
    floatText(`üõ°Ô∏è Shield Bash! ${dmg} +10üõ°Ô∏è`, 'var(--blue)');
    playSFX('shield');
  } else if (key === 'rogue') {
    let dmg = Math.floor(run.hero.atk * 2.5);
    if (battle.enemy.hp > battle.enemy.maxHp * 0.5) dmg = Math.floor(dmg * 1.5);
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    floatText(`üó°Ô∏è Backstab! ${dmg}`, 'var(--gold)');
    playSFX('attack');
  }

  if (battle.enemy.hp <= 0) {
    floorCleared();
    return;
  }
  updateBattleUI();
}

function useUltimate() {
  if (animating || run.ultimateGauge < 100) return;
  run.ultimateGauge = 0;
  const key = run.heroKey;

  playSFX('magic');
  if (key === 'warrior') {
    const dmg = Math.floor(run.hero.atk * 8);
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    floatText(`üíÄ WRATH! ${dmg}`, 'var(--gold)');
  } else if (key === 'mage') {
    const dmg = Math.floor(run.hero.atk * 6);
    battle.enemy.hp = Math.max(0, battle.enemy.hp - dmg);
    // Reset board
    initGrid();
    floatText(`üíÄ ARCANE STORM! ${dmg}`, '#9b59b6');
  } else if (key === 'knight') {
    run.invincibleTurns = 3;
    run.shield += 30;
    floatText(`üíÄ FORTRESS! 3 turns invincible`, 'var(--gold)');
  } else if (key === 'rogue') {
    const totalDmg = run.hero.atk * 3;
    battle.enemy.debuffs.push({type:'poison',turns:3,value:totalDmg});
    floatText(`üíÄ VENOM! ${totalDmg}/turn √ó3`, '#27ae60');
  }

  if (battle.enemy.hp <= 0) {
    floorCleared();
    return;
  }
  updateBattleUI();
}

function usePotion() {
  if (run.potions <= 0) return;
  run.potions--;
  const heal = Math.floor(run.maxHp * 0.3);
  run.hp = Math.min(run.maxHp, run.hp + heal);
  floatText(`üß™ +${heal} HP`, 'var(--green)');
  updateBattleUI();
}

// ===== UI UPDATE =====
function updateBattleUI() {
  if (!run || !battle) return;
  const e = battle.enemy;
  document.getElementById('b-floor').textContent = `F${run.floor}/25`;
  document.getElementById('b-ename').textContent = e.name;
  document.getElementById('b-ehp-fill').style.width = `${(e.hp/e.maxHp)*100}%`;
  document.getElementById('b-ehp-text').textContent = `${Math.max(0,e.hp)}/${e.maxHp}`;
  document.getElementById('b-intent').innerHTML = `Next: ${battle.intent.label}`;
  document.getElementById('b-esprite').textContent = e.icon;
  document.getElementById('b-boss-label').style.display = e.isBoss ? 'block' : 'none';
  
  // Enemy debuffs
  const debuffsEl = document.getElementById('b-edebuffs');
  debuffsEl.innerHTML = e.debuffs.map(d => `<span class="debuff-icon">${d.type==='poison'?'üü¢':''} ${d.turns}t</span>`).join('');

  // Player
  document.getElementById('b-hp-text').textContent = `${Math.max(0,run.hp)}/${run.maxHp}`;
  document.getElementById('b-hp-fill').style.width = `${Math.max(0,(run.hp/run.maxHp)*100)}%`;
  document.getElementById('b-shield-text').textContent = run.shield;
  document.getElementById('b-shield-fill').style.width = `${Math.min(100,(run.shield/50)*100)}%`;
  document.getElementById('b-mana-text').textContent = `${run.mana}/${run.maxMana}`;
  document.getElementById('b-mana-fill').style.width = `${(run.mana/run.maxMana)*100}%`;
  document.getElementById('b-ult-text').textContent = `${run.ultimateGauge}%`;
  document.getElementById('b-ult-fill').style.width = `${run.ultimateGauge}%`;
  document.getElementById('b-gold').textContent = run.gold;

  // Buttons
  const h = HEROES[run.heroKey];
  document.getElementById('btn-skill').disabled = run.mana < h.skillCost;
  document.getElementById('btn-skill').textContent = `‚ö° SKILL (${h.skillCost})`;
  document.getElementById('btn-ult').disabled = run.ultimateGauge < 100;
  document.getElementById('btn-potion').disabled = run.potions <= 0;
  document.getElementById('potion-count').textContent = run.potions;

  // Relics
  const relicsEl = document.getElementById('b-relics');
  relicsEl.innerHTML = run.relics.map(r => `<span class="relic-icon" title="${r.name}">${r.icon}</span>`).join('');
}

// ===== FLOOR CLEARED =====
function floorCleared() {
  killCount++;
  animating = false;
  playSFX('door');
  
  // Gold reward
  let goldReward = 10 + run.floor * 3 + Math.floor(Math.random() * 10);
  if (hasRelic('gold_idol')) goldReward = Math.floor(goldReward * 1.5);
  run.gold += goldReward;

  // Remove some curse gems
  for (let r = 0; r < GRID_SIZE; r++)
    for (let c = 0; c < GRID_SIZE; c++)
      if (grid[r][c] === 'curse') grid[r][c] = randomGem(r, c);

  // Check victory
  if (run.floor >= 25) {
    victory();
    return;
  }

  // Every 5th floor: event choice
  if (run.floor % 5 === 0) {
    showEventScreen();
  } else {
    showRewardScreen();
  }
}

function showRewardScreen() {
  showScreen('reward-screen');
  document.getElementById('rw-sub').textContent = `Floor ${run.floor} cleared! +${10+run.floor*3}g`;
  
  const cards = document.getElementById('rw-cards');
  cards.innerHTML = '';
  
  // Pick 3 random relics not already owned
  const owned = new Set(run.relics.map(r => r.id));
  const available = RELICS.filter(r => !owned.has(r.id));
  const picks = [];
  const pool = [...available];
  for (let i = 0; i < 3 && pool.length > 0; i++) {
    const idx = Math.floor(Math.random() * pool.length);
    picks.push(pool.splice(idx, 1)[0]);
  }

  picks.forEach(relic => {
    const card = document.createElement('div');
    card.className = 'reward-card';
    card.innerHTML = `
      <div class="r-icon">${relic.icon}</div>
      <div class="r-name">${relic.name}</div>
      <div class="r-desc">${relic.desc}</div>
    `;
    card.onclick = () => {
      playSFX('item');
      if (run.relics.length < run.relicSlots) {
        run.relics.push(relic);
        if (!meta.codex.relics.includes(relic.id)) {
          meta.codex.relics.push(relic.id);
          saveMeta();
        }
        // Apply immediate effects
        if (relic.effect === 'max_hp') {
          run.maxHp += relic.value;
          run.hp += relic.value;
        }
      }
      nextFloor();
    };
    cards.appendChild(card);
  });

  // If no relics available, show gold/heal options
  if (picks.length === 0) {
    const healCard = document.createElement('div');
    healCard.className = 'reward-card';
    healCard.innerHTML = `<div class="r-icon">‚ù§Ô∏è</div><div class="r-name">Heal</div><div class="r-desc">+30% HP</div>`;
    healCard.onclick = () => {
      run.hp = Math.min(run.maxHp, run.hp + Math.floor(run.maxHp * 0.3));
      nextFloor();
    };
    cards.appendChild(healCard);
  }
}

function showEventScreen() {
  showScreen('event-screen');
  const title = document.getElementById('ev-title');
  const choices = document.getElementById('ev-choices');
  choices.innerHTML = '';
  
  title.textContent = `üè∞ Floor ${run.floor} - Choose Path`;
  
  const options = [
    {icon:'‚öîÔ∏è', label:'Elite Battle', desc:'Harder enemy, rare relic reward', action:() => { nextFloor(); }},
    {icon:'üõí', label:'Shop', desc:`Spend gold (${run.gold}g) on items`, action:() => showShop()},
    {icon:'üèïÔ∏è', label:'Rest', desc:'Heal 30% HP or upgrade a relic', action:() => {
      run.hp = Math.min(run.maxHp, run.hp + Math.floor(run.maxHp * 0.3));
      floatText('üíö Rested!', 'var(--green)');
      nextFloor();
    }}
  ];
  
  options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'event-btn';
    btn.innerHTML = `<span class="ev-icon">${opt.icon}</span> <strong>${opt.label}</strong><br><small style="color:#aaa">${opt.desc}</small>`;
    btn.onclick = opt.action;
    choices.appendChild(btn);
  });
}

function showShop() {
  const choices = document.getElementById('ev-choices');
  choices.innerHTML = '';
  document.getElementById('ev-title').textContent = `üõí Shop (${run.gold}g)`;
  
  const items = [
    {icon:'üß™', name:'Health Potion', cost:30, action:() => { run.potions++; }},
    {icon:'‚ù§Ô∏è', name:'Max HP +15', cost:50, action:() => { run.maxHp += 15; run.hp += 15; }},
    {icon:'‚öîÔ∏è', name:'ATK +3', cost:60, action:() => { run.hero.atk += 3; }},
    {icon:'üõ°Ô∏è', name:'DEF +3', cost:40, action:() => { run.hero.def += 3; }},
    {icon:'‚ú®', name:'Max Mana +3', cost:45, action:() => { run.maxMana += 3; }},
    {icon:'üíÄ', name:'Remove 3 Curses', cost:20, action:() => {
      let removed = 0;
      for (let r = 0; r < GRID_SIZE && removed < 3; r++)
        for (let c = 0; c < GRID_SIZE && removed < 3; c++)
          if (grid[r][c] === 'curse') { grid[r][c] = randomGem(r,c); removed++; }
    }}
  ];
  
  items.forEach(item => {
    const btn = document.createElement('button');
    btn.className = 'event-btn';
    btn.disabled = run.gold < item.cost;
    btn.innerHTML = `<span class="ev-icon">${item.icon}</span> <strong>${item.name}</strong> ‚Äî ${item.cost}g`;
    btn.onclick = () => {
      if (run.gold >= item.cost) {
        run.gold -= item.cost;
        item.action();
        showShop(); // Refresh
      }
    };
    choices.appendChild(btn);
  });
  
  const leaveBtn = document.createElement('button');
  leaveBtn.className = 'event-btn';
  leaveBtn.innerHTML = `<span class="ev-icon">üö™</span> <strong>Leave Shop</strong>`;
  leaveBtn.onclick = () => nextFloor();
  choices.appendChild(leaveBtn);
}

function skipReward() {
  nextFloor();
}

function nextFloor() {
  run.floor++;
  if (run.floor > 25) {
    victory();
    return;
  }
  startFloor();
}

// ===== GAME OVER =====
function gameOver() {
  animating = false;
  stopBGM();
  playSFX('death');
  const sp = run.floor * 10 + killCount * 2;
  meta.soulPoints += sp;
  if (run.floor > meta.bestFloor) meta.bestFloor = run.floor;
  saveMeta();

  document.getElementById('go-floor').textContent = run.floor;
  document.getElementById('go-kills').textContent = killCount;
  document.getElementById('go-chains').textContent = totalChains;
  document.getElementById('go-sp').textContent = `+${sp} Soul Points`;
  showScreen('gameover-screen');
}

function victory() {
  animating = false;
  stopBGM();
  playSFX('levelup');
  const sp = 25 * 10 + killCount * 2 + 200; // bonus for clearing
  meta.soulPoints += sp;
  meta.bestFloor = 25;
  saveMeta();

  document.getElementById('v-kills').textContent = killCount;
  document.getElementById('v-sp').textContent = `+${sp} Soul Points`;
  showScreen('victory-screen');
}

function returnToTitle() {
  stopBGM();
  run = null;
  battle = null;
  selectedGem = null;
  animating = false;
  showScreen('title-screen');
}

// ===== UPGRADES =====
function renderUpgrades() {
  document.getElementById('u-sp').textContent = meta.soulPoints;
  const list = document.getElementById('upgrade-list');
  list.innerHTML = '';
  
  UPGRADES.forEach(up => {
    const lvl = getUpgradeLevel(up.id);
    const maxed = lvl >= up.maxLvl;
    const cost = maxed ? '‚Äî' : up.costs[lvl];
    const canBuy = !maxed && meta.soulPoints >= cost;
    
    // Hide unlock upgrades if already unlocked
    if (up.effect === 'unlock' && meta.unlockedHeroes.includes(up.value)) return;

    const item = document.createElement('div');
    item.className = 'upgrade-item';
    item.innerHTML = `
      <div class="u-info">
        <div class="u-name">${up.name}</div>
        <div class="u-desc">${up.desc}</div>
        <div class="u-level">Lv ${lvl}/${up.maxLvl} ${maxed ? '‚úÖ MAX' : `| Cost: ${cost} SP`}</div>
      </div>
      <button class="u-buy" ${canBuy ? '' : 'disabled'} onclick="buyUpgrade('${up.id}')">${maxed ? 'MAX' : 'BUY'}</button>
    `;
    list.appendChild(item);
  });
}

function buyUpgrade(id) {
  const up = UPGRADES.find(u => u.id === id);
  const lvl = getUpgradeLevel(id);
  if (lvl >= up.maxLvl) return;
  const cost = up.costs[lvl];
  if (meta.soulPoints < cost) return;
  
  meta.soulPoints -= cost;
  meta.upgrades[id] = lvl + 1;
  
  if (up.effect === 'unlock') {
    meta.unlockedHeroes.push(up.value);
  }
  
  saveMeta();
  renderUpgrades();
}

// ===== CODEX =====
function renderCodex() {
  const content = document.getElementById('codex-content');
  const totalMonsters = MONSTERS.length;
  const totalRelics = RELICS.length;
  const totalBosses = Object.keys(BOSSES).length;
  
  content.innerHTML = `
    <div class="codex-section">
      <h3>üëπ Monsters (${meta.codex.monsters.length}/${totalMonsters})</h3>
      <div class="codex-grid">
        ${MONSTERS.map(m => {
          const found = meta.codex.monsters.includes(m.name);
          return `<div class="codex-entry ${found?'':'undiscovered'}"><div class="ce-icon">${found?m.icon:'?'}</div>${found?m.name:'???'}</div>`;
        }).join('')}
      </div>
    </div>
    <div class="codex-section">
      <h3>üíÄ Bosses (${meta.codex.bosses.length}/${totalBosses})</h3>
      <div class="codex-grid">
        ${Object.values(BOSSES).map(b => {
          const found = meta.codex.bosses.includes(b.name);
          return `<div class="codex-entry ${found?'':'undiscovered'}"><div class="ce-icon">${found?b.icon:'?'}</div>${found?b.name:'???'}</div>`;
        }).join('')}
      </div>
    </div>
    <div class="codex-section">
      <h3>üè∫ Relics (${meta.codex.relics.length}/${totalRelics})</h3>
      <div class="codex-grid">
        ${RELICS.map(r => {
          const found = meta.codex.relics.includes(r.id);
          return `<div class="codex-entry ${found?'':'undiscovered'}"><div class="ce-icon">${found?r.icon:'?'}</div>${found?r.name:'???'}</div>`;
        }).join('')}
      </div>
    </div>
  `;
}

// ===== HELPERS =====
function hasRelic(id) {
  return run && run.relics.some(r => r.id === id);
}

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

function floatText(text, color, onEnemy) {
  const container = document.getElementById(onEnemy ? 'b-esprite' : 'grid-container');
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  el.style.color = color;
  el.style.left = `${30 + Math.random()*40}%`;
  el.style.top = `${30 + Math.random()*30}%`;
  container.style.position = 'relative';
  container.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

function showChainPopup(count) {
  const container = document.getElementById('grid-container');
  const el = document.createElement('div');
  el.className = 'chain-popup';
  el.textContent = `${count}√ó CHAIN!`;
  container.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

// ===== INIT =====
async function init() {
  await openDB();
  await loadMeta();
  
  // Ensure codex arrays exist
  if (!meta.codex) meta.codex = {monsters:[],relics:[],bosses:[]};
  if (!meta.codex.monsters) meta.codex.monsters = [];
  if (!meta.codex.relics) meta.codex.relics = [];
  if (!meta.codex.bosses) meta.codex.bosses = [];
  if (!meta.upgrades) meta.upgrades = {};
  if (!meta.unlockedHeroes) meta.unlockedHeroes = ['warrior'];
  
  updateTitleStats();
}

init();
</script>
<script src="../tg-sdk-wrapper.js"></script>
<script src="../cross-promo.js"></script>
</body>
</html>
