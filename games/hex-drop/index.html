<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Hex Drop Puzzle</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  overflow: hidden;
  touch-action: none;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  user-select: none;
  -webkit-user-select: none;
}
canvas { display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Colors
const BG = '#1a1a2e';
const CELL_EMPTY = '#16213e';
const CELL_BORDER = '#0f3460';
const COLORS = ['#FF6B6B','#4ECDC4','#45B7D1','#96CEB4','#FFEAA7','#DDA0DD'];
const GLOW_ALPHA = 0.3;

// Grid params
const GRID_RADIUS = 4; // rings around center (0..4 = 5 rings, 61 cells)
const HEX_SIZE = 0;    // computed on resize
let hexSize = 28;
let gridCenterX = 0, gridCenterY = 0;

// Game state
const STATE_TITLE = 0, STATE_PLAY = 1, STATE_OVER = 2;
let state = STATE_TITLE;
let score = 0;
let bestScore = parseInt(localStorage.getItem('hexdrop_best') || '0');
let grid = {}; // key "q,r" -> {color}
let tray = []; // 3 pieces [{cells:[{dq,dr}], color}]
let dragging = null; // {pieceIdx, startX, startY, curX, curY}
let particles = [];
let clearAnim = []; // [{q,r,t}]
let comboText = null; // {text, x, y, t}

// Piece definitions (axial offsets)
const PIECE_DEFS = [
  // Single
  [{dq:0,dr:0}],
  // Duo
  [{dq:0,dr:0},{dq:1,dr:0}],
  // Trio line
  [{dq:0,dr:0},{dq:1,dr:0},{dq:2,dr:0}],
  // Trio bend
  [{dq:0,dr:0},{dq:1,dr:0},{dq:1,dr:-1}],
  // Quad line
  [{dq:0,dr:0},{dq:1,dr:0},{dq:2,dr:0},{dq:3,dr:0}],
  // Quad Z
  [{dq:0,dr:0},{dq:1,dr:0},{dq:1,dr:-1},{dq:2,dr:-1}],
  // Triangle
  [{dq:0,dr:0},{dq:1,dr:0},{dq:0,dr:1}],
];

// Rotate piece defs for variety
function rotateCW(cells) {
  return cells.map(c => ({dq: -c.dr, dr: c.dq + c.dr}));
}

function allRotations(cells) {
  let rots = [cells];
  let cur = cells;
  for (let i = 0; i < 5; i++) {
    cur = rotateCW(cur);
    // Normalize
    const minQ = Math.min(...cur.map(c=>c.dq));
    const minR = Math.min(...cur.map(c=>c.dr));
    cur = cur.map(c=>({dq:c.dq-minQ, dr:c.dr-minR}));
    // Check duplicate
    const key = JSON.stringify(cur.sort((a,b)=>a.dq-b.dq||a.dr-b.dr));
    if (!rots.some(r => JSON.stringify(r.sort((a,b)=>a.dq-b.dq||a.dr-b.dr)) === key)) {
      rots.push([...cur]);
    }
  }
  return rots;
}

// All piece variants
let ALL_PIECES = [];
PIECE_DEFS.forEach(def => {
  allRotations(def).forEach(rot => ALL_PIECES.push(rot));
});

// Hex math
function axialToPixel(q, r) {
  const x = hexSize * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
  const y = hexSize * (3/2 * r);
  return {x: gridCenterX + x, y: gridCenterY + y};
}

function pixelToAxial(px, py) {
  const x = px - gridCenterX;
  const y = py - gridCenterY;
  const q = (Math.sqrt(3)/3 * x - 1/3 * y) / hexSize;
  const r = (2/3 * y) / hexSize;
  return axialRound(q, r);
}

function axialRound(q, r) {
  const s = -q - r;
  let rq = Math.round(q), rr = Math.round(r), rs = Math.round(s);
  const dq = Math.abs(rq - q), dr = Math.abs(rr - r), ds = Math.abs(rs - s);
  if (dq > dr && dq > ds) rq = -rr - rs;
  else if (dr > ds) rr = -rq - rs;
  return {q: rq, r: rr};
}

function isInGrid(q, r) {
  const s = -q - r;
  return Math.abs(q) <= GRID_RADIUS && Math.abs(r) <= GRID_RADIUS && Math.abs(s) <= GRID_RADIUS;
}

function cellKey(q, r) { return q + ',' + r; }

function drawHex(cx, cy, size, fill, stroke, lineW) {
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const angle = Math.PI / 180 * (60 * i - 30);
    const x = cx + size * Math.cos(angle);
    const y = cy + size * Math.sin(angle);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = lineW || 1; ctx.stroke(); }
}

// Init grid
function initGrid() {
  grid = {};
  for (let q = -GRID_RADIUS; q <= GRID_RADIUS; q++) {
    for (let r = -GRID_RADIUS; r <= GRID_RADIUS; r++) {
      if (isInGrid(q, r)) {
        grid[cellKey(q, r)] = null; // null = empty
      }
    }
  }
}

// Generate random piece
function randomPiece() {
  const cells = ALL_PIECES[Math.floor(Math.random() * ALL_PIECES.length)];
  const color = COLORS[Math.floor(Math.random() * COLORS.length)];
  return {cells: cells.map(c=>({...c})), color};
}

// Fill tray
function fillTray() {
  tray = [randomPiece(), randomPiece(), randomPiece()];
}

// Check if piece can be placed
function canPlace(piece, q0, r0) {
  for (const c of piece.cells) {
    const q = q0 + c.dq, r = r0 + c.dr;
    if (!isInGrid(q, r)) return false;
    if (grid[cellKey(q, r)] !== null) return false;
  }
  return true;
}

// Place piece
function placePiece(piece, q0, r0) {
  for (const c of piece.cells) {
    grid[cellKey(q0 + c.dq, r0 + c.dr)] = piece.color;
  }
}

// Get lines to clear
function getLinesToClear() {
  const dirs = [
    {dq:1, dr:0},   // →
    {dq:0, dr:1},   // ↘
    {dq:1, dr:-1},  // ↗
  ];
  let toClear = new Set();

  for (const dir of dirs) {
    // For each direction, iterate all lines
    const visited = new Set();
    for (const key in grid) {
      const [q, r] = key.split(',').map(Number);
      // Find start of line (go opposite direction)
      let sq = q, sr = r;
      while (isInGrid(sq - dir.dq, sr - dir.dr)) {
        sq -= dir.dq;
        sr -= dir.dr;
      }
      const lineKey = `${dir.dq},${dir.dr},${sq},${sr}`;
      if (visited.has(lineKey)) continue;
      visited.add(lineKey);

      // Collect line cells
      let line = [];
      let cq = sq, cr = sr;
      while (isInGrid(cq, cr)) {
        line.push({q: cq, r: cr});
        cq += dir.dq;
        cr += dir.dr;
      }

      // Check if all filled
      if (line.length > 0 && line.every(c => grid[cellKey(c.q, c.r)] !== null)) {
        line.forEach(c => toClear.add(cellKey(c.q, c.r)));
      }
    }
  }
  return toClear;
}

// Clear lines and score
function clearLines() {
  const toClear = getLinesToClear();
  if (toClear.size === 0) return 0;

  // Count lines (approximate by direction)
  const dirs = [{dq:1,dr:0},{dq:0,dr:1},{dq:1,dr:-1}];
  let lineCount = 0;
  for (const dir of dirs) {
    const visited = new Set();
    for (const key of toClear) {
      const [q, r] = key.split(',').map(Number);
      let sq = q, sr = r;
      while (isInGrid(sq - dir.dq, sr - dir.dr) && toClear.has(cellKey(sq - dir.dq, sr - dir.dr))) {
        sq -= dir.dq; sr -= dir.dr;
      }
      const lk = `${sq},${sr},${dir.dq},${dir.dr}`;
      if (!visited.has(lk)) {
        // Verify it's a full line
        let len = 0, cq = sq, cr = sr;
        while (isInGrid(cq, cr)) { len++; cq += dir.dq; cr += dir.dr; }
        let inClear = 0; cq = sq; cr = sr;
        while (isInGrid(cq, cr) && toClear.has(cellKey(cq, cr))) { inClear++; cq += dir.dq; cr += dir.dr; }
        if (inClear === len) {
          visited.add(lk);
          lineCount++;
        }
      }
    }
  }

  // Spawn particles & clear anim
  for (const key of toClear) {
    const [q, r] = key.split(',').map(Number);
    const {x, y} = axialToPixel(q, r);
    const color = grid[key];
    for (let i = 0; i < 6; i++) {
      particles.push({
        x, y, 
        vx: (Math.random()-0.5)*4, 
        vy: (Math.random()-0.5)*4 - 2,
        color: color || '#fff',
        life: 1,
        size: hexSize * 0.3
      });
    }
    clearAnim.push({q, r, t: 1});
    grid[key] = null;
  }

  // Score
  const combo = lineCount >= 3 ? 2 : lineCount >= 2 ? 1.5 : 1;
  const points = Math.floor(toClear.size * 10 + lineCount * 100 * combo);
  score += points;

  if (lineCount >= 2) {
    comboText = {text: `${lineCount}x COMBO!`, x: gridCenterX, y: gridCenterY - hexSize * 3, t: 1.5};
  }

  if (score > bestScore) {
    bestScore = score;
    localStorage.setItem('hexdrop_best', bestScore.toString());
  }

  return toClear.size;
}

// Check game over
function checkGameOver() {
  for (const piece of tray) {
    if (!piece) continue;
    for (const key in grid) {
      const [q, r] = key.split(',').map(Number);
      if (canPlace(piece, q, r)) return false;
    }
  }
  return tray.filter(p => p !== null).length > 0;
}

// Resize
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  const maxW = Math.min(canvas.width * 0.85, 500);
  hexSize = maxW / (GRID_RADIUS * 2 + 1) / Math.sqrt(3) * 0.95;
  hexSize = Math.min(hexSize, 28);
  gridCenterX = canvas.width / 2;
  gridCenterY = canvas.height * 0.38;
}
window.addEventListener('resize', resize);
resize();

// Tray positions
function getTrayPositions() {
  const trayY = canvas.height * 0.78;
  const spacing = canvas.width / 4;
  return [
    {x: spacing, y: trayY},
    {x: spacing * 2, y: trayY},
    {x: spacing * 3, y: trayY},
  ];
}

// Draw piece at position (for tray)
function drawPieceAt(piece, cx, cy, scale, alpha) {
  if (!piece) return;
  const s = hexSize * scale;
  // Center piece
  let sumX = 0, sumY = 0;
  const positions = piece.cells.map(c => {
    const x = s * (Math.sqrt(3) * c.dq + Math.sqrt(3)/2 * c.dr);
    const y = s * (3/2 * c.dr);
    sumX += x; sumY += y;
    return {x, y};
  });
  const offX = sumX / positions.length;
  const offY = sumY / positions.length;
  
  ctx.globalAlpha = alpha;
  positions.forEach((p, i) => {
    drawHex(cx + p.x - offX, cy + p.y - offY, s * 0.9, piece.color, null);
    // Glow
    ctx.globalAlpha = alpha * GLOW_ALPHA;
    drawHex(cx + p.x - offX, cy + p.y - offY, s * 1.05, piece.color, null);
    ctx.globalAlpha = alpha;
  });
  ctx.globalAlpha = 1;
}

// Get piece bounds for hit testing
function getPieceBounds(piece, cx, cy, scale) {
  const s = hexSize * scale;
  let sumX = 0, sumY = 0;
  const positions = piece.cells.map(c => {
    const x = s * (Math.sqrt(3) * c.dq + Math.sqrt(3)/2 * c.dr);
    const y = s * (3/2 * c.dr);
    sumX += x; sumY += y;
    return {x, y};
  });
  const offX = sumX / positions.length;
  const offY = sumY / positions.length;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  positions.forEach(p => {
    const px = cx + p.x - offX, py = cy + p.y - offY;
    minX = Math.min(minX, px - s);
    minY = Math.min(minY, py - s);
    maxX = Math.max(maxX, px + s);
    maxY = Math.max(maxY, py + s);
  });
  return {minX, minY, maxX, maxY};
}

// Drawing
function draw() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (state === STATE_TITLE) {
    drawTitle();
    return;
  }

  // Draw grid
  for (const key in grid) {
    const [q, r] = key.split(',').map(Number);
    const {x, y} = axialToPixel(q, r);
    const color = grid[key];
    
    // Check if in clear animation
    const ca = clearAnim.find(a => a.q === q && a.r === r);
    if (ca) {
      ctx.globalAlpha = ca.t;
      drawHex(x, y, hexSize * (1 + (1-ca.t)*0.3) * 0.9, '#fff', null);
      ctx.globalAlpha = 1;
    } else if (color) {
      drawHex(x, y, hexSize * 0.9, color, null);
      // Inner glow
      ctx.globalAlpha = 0.3;
      drawHex(x, y, hexSize * 0.6, '#fff', null);
      ctx.globalAlpha = 1;
    } else {
      drawHex(x, y, hexSize * 0.9, CELL_EMPTY, CELL_BORDER, 1);
    }
  }

  // Draw drag preview
  if (dragging !== null && dragging.pieceIdx !== null) {
    const piece = tray[dragging.pieceIdx];
    if (piece) {
      const target = pixelToAxial(dragging.curX, dragging.curY - hexSize * 2);
      const valid = canPlace(piece, target.q, target.r);
      
      // Preview on grid
      ctx.globalAlpha = 0.5;
      for (const c of piece.cells) {
        const pq = target.q + c.dq, pr = target.r + c.dr;
        if (isInGrid(pq, pr)) {
          const {x, y} = axialToPixel(pq, pr);
          drawHex(x, y, hexSize * 0.9, valid ? piece.color : '#ff0000', null);
        }
      }
      ctx.globalAlpha = 1;

      // Piece following finger
      drawPieceAt(piece, dragging.curX, dragging.curY - hexSize * 2, 1, 0.7);
    }
  }

  // Draw tray
  const trayPos = getTrayPositions();
  tray.forEach((piece, i) => {
    if (!piece) return;
    if (dragging && dragging.pieceIdx === i) return; // being dragged
    drawPieceAt(piece, trayPos[i].x, trayPos[i].y, 0.6, 1);
  });

  // Draw particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  // Combo text
  if (comboText && comboText.t > 0) {
    ctx.globalAlpha = Math.min(1, comboText.t);
    ctx.fillStyle = '#FFEAA7';
    ctx.font = `bold ${Math.floor(hexSize * 1.5)}px 'Segoe UI', sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(comboText.text, comboText.x, comboText.y);
    ctx.globalAlpha = 1;
  }

  // Score
  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.floor(hexSize * 0.9)}px 'Segoe UI', sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(`SCORE: ${score}`, canvas.width / 2, hexSize * 1.8);

  ctx.fillStyle = '#888';
  ctx.font = `${Math.floor(hexSize * 0.55)}px 'Segoe UI', sans-serif`;
  ctx.fillText(`BEST: ${bestScore}`, canvas.width / 2, hexSize * 2.6);

  // Game over overlay
  if (state === STATE_OVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = '#FF6B6B';
    ctx.font = `bold ${Math.floor(hexSize * 2)}px 'Segoe UI', sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - hexSize * 2);

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${Math.floor(hexSize * 1.2)}px 'Segoe UI', sans-serif`;
    ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2);

    ctx.fillStyle = '#FFEAA7';
    ctx.font = `${Math.floor(hexSize * 0.8)}px 'Segoe UI', sans-serif`;
    ctx.fillText(`Best: ${bestScore}`, canvas.width/2, canvas.height/2 + hexSize * 1.5);

    ctx.fillStyle = '#4ECDC4';
    ctx.font = `bold ${Math.floor(hexSize * 0.9)}px 'Segoe UI', sans-serif`;
    ctx.fillText('TAP TO RESTART', canvas.width/2, canvas.height/2 + hexSize * 3.5);
  }
}

function drawTitle() {
  // Logo
  ctx.fillStyle = '#4ECDC4';
  ctx.font = `bold ${Math.floor(hexSize * 2.5)}px 'Segoe UI', sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText('HEX DROP', canvas.width/2, canvas.height * 0.3);

  // Decorative hex
  const deco = [
    {q:0,r:0,c:'#FF6B6B'}, {q:1,r:0,c:'#4ECDC4'}, {q:-1,r:0,c:'#45B7D1'},
    {q:0,r:1,c:'#96CEB4'}, {q:0,r:-1,c:'#FFEAA7'}, {q:1,r:-1,c:'#DDA0DD'}
  ];
  const decoY = canvas.height * 0.48;
  deco.forEach(d => {
    const x = canvas.width/2 + hexSize * 1.5 * (Math.sqrt(3) * d.q + Math.sqrt(3)/2 * d.r);
    const y = decoY + hexSize * 1.5 * (3/2 * d.r);
    drawHex(x, y, hexSize * 1.3, d.c, null);
  });

  ctx.fillStyle = '#888';
  ctx.font = `${Math.floor(hexSize * 0.7)}px 'Segoe UI', sans-serif`;
  ctx.fillText(`BEST: ${bestScore}`, canvas.width/2, canvas.height * 0.65);

  ctx.fillStyle = '#fff';
  ctx.font = `bold ${Math.floor(hexSize * 0.9)}px 'Segoe UI', sans-serif`;
  const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 500);
  ctx.globalAlpha = pulse;
  ctx.fillText('TAP TO START', canvas.width/2, canvas.height * 0.75);
  ctx.globalAlpha = 1;
}

// Update
function update(dt) {
  // Particles
  particles = particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life -= dt * 2;
    p.size *= 0.98;
    return p.life > 0;
  });

  // Clear animations
  clearAnim = clearAnim.filter(a => {
    a.t -= dt * 3;
    return a.t > 0;
  });

  // Combo text
  if (comboText) {
    comboText.t -= dt;
    comboText.y -= dt * 30;
    if (comboText.t <= 0) comboText = null;
  }
}

// Input
function getPos(e) {
  const t = e.touches ? e.touches[0] || e.changedTouches[0] : e;
  return {x: t.clientX, y: t.clientY};
}

function onDown(e) {
  e.preventDefault();
  const pos = getPos(e);

  if (state === STATE_TITLE) {
    startGame();
    return;
  }
  if (state === STATE_OVER) {
    startGame();
    return;
  }

  // Check tray hit
  const trayPos = getTrayPositions();
  for (let i = 0; i < tray.length; i++) {
    if (!tray[i]) continue;
    const bounds = getPieceBounds(tray[i], trayPos[i].x, trayPos[i].y, 0.6);
    if (pos.x >= bounds.minX && pos.x <= bounds.maxX && pos.y >= bounds.minY && pos.y <= bounds.maxY) {
      dragging = {pieceIdx: i, startX: pos.x, startY: pos.y, curX: pos.x, curY: pos.y};
      return;
    }
  }
}

function onMove(e) {
  e.preventDefault();
  if (!dragging) return;
  const pos = getPos(e);
  dragging.curX = pos.x;
  dragging.curY = pos.y;
}

function onUp(e) {
  e.preventDefault();
  if (!dragging) return;
  
  const piece = tray[dragging.pieceIdx];
  if (piece) {
    const target = pixelToAxial(dragging.curX, dragging.curY - hexSize * 2);
    if (canPlace(piece, target.q, target.r)) {
      placePiece(piece, target.q, target.r);
      score += piece.cells.length * 10;
      tray[dragging.pieceIdx] = null;
      
      // Clear lines
      clearLines();

      // Refill tray if all placed
      if (tray.every(p => p === null)) {
        fillTray();
      }

      // Check game over
      if (checkGameOver()) {
        state = STATE_OVER;
      }

      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('hexdrop_best', bestScore.toString());
      }
    }
  }
  dragging = null;
}

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
canvas.addEventListener('touchmove', onMove, {passive: false});
canvas.addEventListener('touchend', onUp, {passive: false});

function startGame() {
  state = STATE_PLAY;
  score = 0;
  initGrid();
  fillTray();
  particles = [];
  clearAnim = [];
  comboText = null;
  dragging = null;
}

// Game loop
let lastTime = 0;
function loop(time) {
  const dt = Math.min((time - lastTime) / 1000, 0.1);
  lastTime = time;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
